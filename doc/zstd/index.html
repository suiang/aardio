<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>zstd 1.4.8 中文手册</title>
</head>
<body>

<h1>zstd 1.4.8 中文手册</h1>
<hr>
<a name="Contents"></a><h2>目录</h2>
<ol>
<li><a href="#Chapter1">简介</a></li>
<li><a href="#Chapter2">版本</a></li>
<li><a href="#Chapter3">简单 API</a></li>
<li><a href="#Chapter4">明确上下文</a></li>
<li><a href="#Chapter5">高级压缩 API</a></li>
<li><a href="#Chapter6">高级解压 API</a></li>
<li><a href="#Chapter7">数据流</a></li>
<li><a href="#Chapter8">数据流压缩 - HowTo</a></li>
<li><a href="#Chapter9">数据流解压 - HowTo</a></li>
<li><a href="#Chapter10">简单字典 API</a></li>
<li><a href="#Chapter11">批量处理字典 API</a></li>
<li><a href="#Chapter12">字典辅助函数</a></li>
<li><a href="#Chapter13">高级字典和前缀 API</a></li>
<li><a href="#Chapter14">实验性 API (仅静态链接)</a></li>
<li><a href="#Chapter15">帧大小函数</a></li>
<li><a href="#Chapter16">内存管理</a></li>
<li><a href="#Chapter17">高级压缩函数</a></li>
<li><a href="#Chapter18">高级解压函数</a></li>
<li><a href="#Chapter19">高级数据流函数</a></li>
<li><a href="#Chapter20">无缓冲区和同步的内部数据流函数</a></li>
<li><a href="#Chapter21">无缓冲区数据流压缩 (同步模式)</a></li>
<li><a href="#Chapter22">无缓冲区数据流解压 (同步模式)</a></li>
<li><a href="#Chapter23">区块级 API</a></li>
</ol>
<hr>
<a name="Chapter1"></a><h2>简介</h2><pre>
  zstd 是 Zstandard 的简称，是一种快速无损压缩算法，针对 zlib 级的实时压缩场景，压缩比更好。
  zstd 压缩库提供了内存压缩和解压功能。

  该库支持从 1 到 ZSTD_maxCLevel() 的常规压缩级别。
  目前是22。级别 >= 20，标注为 `--ultra`，应谨慎使用，因为它们需要更多的内存。
  该库还提供了负压缩级别，扩大了速度与比率的范围。级别越低，速度越快（以压缩为代价）。

  压缩可以用：
    - 单一步骤 (称为：简单 API)
    - 单一步骤，重复使用上下文 （称为：明确上下文）
    - 无限多步 (称为：数据流压缩)

  使用字典可以极大地提高对小数据的压缩率。字典压缩可以：
    - 单一步骤 (称为： 简单字典 API)
    - 单一步骤，复用字典 (称为： 批量处理字典 API)

  高级实验函数可以在包含 zstd.h 之前使用 `#define ZSTD_STATIC_LINKING_ONLY` 来访问。

  高级实验性 API 永远不应该与动态链接库一起使用。它们并不稳定；
  它们的定义或签名可能在未来发生变化，只允许静态链接。
<BR></pre>

<a name="Chapter2"></a><h2>版本</h2><pre></pre>

<pre><b>unsigned ZSTD_versionNumber(void);
</b><p>  返回运行时库的版本，值为 (MAJOR*100*100 + MINOR*100 + RELEASE).
</p></pre><BR>

<pre><b>const char* ZSTD_versionString(void);
</b><p>  返回运行时库的版本， 如 "1.4.5". 需要 v1.3.0+.
</p></pre><BR>

<a name="Chapter3"></a><h2>简单 API</h2><pre></pre>

<pre><b>size_t ZSTD_compress( void* dst, size_t dstCapacity,
                const void* src, size_t srcSize,
                      int compressionLevel);
</b><p>  将 `src` 内容作为一个单一的 zstd 压缩帧压缩到已经分配的 `dst` 中。
  提示：如果 `dstCapacity` >= `ZSTD_compressBound(srcSize)`，压缩运行更快。
  @return : 压缩后写入 `dst` 的大小 (<= `dstCapacity`)。
            或者如果失败了，则是一个错误代码 （可以使用 ZSTD_isError() 来测试）。
</p></pre><BR>

<pre><b>size_t ZSTD_decompress( void* dst, size_t dstCapacity,
                  const void* src, size_t compressedSize);
</b><p>  `compressedSize` : 必须是一些被压缩或可跳过的帧的确切大小。
  `dstCapacity` 是要重新生成的原始大小的上界。
  如果用户不能提供一个最大的上界，最好使用数据流模式来解压数据。
  @return : 解压到 `dst` 的字节数（<= `dstCapacity`）。
            或者如果失败的话，则是一个错误代码 (可以使用 ZSTD_isError() 来测试)。
</p></pre><BR>

<pre><b>#define ZSTD_CONTENTSIZE_UNKNOWN (0ULL - 1)
#define ZSTD_CONTENTSIZE_ERROR   (0ULL - 2)
unsigned long long ZSTD_getFrameContentSize(const void *src, size_t srcSize);
</b><p>  `src`应指向一个ZSTD编码帧的开始。
  `srcSize`必须至少和帧头一样大。
            提示：任何尺寸 >= `ZSTD_frameHeaderSize_max` 都足够大。
  @return : - `src` 帧内容的解压大小，如果知道的话。
            - ZSTD_CONTENTSIZE_UNKNOWN，如果不能确定大小。
            - ZSTD_CONTENTSIZE_ERROR 如果发生错误 (例如无效的数字，srcSize 太小)
   注1：返回值为 0 表示该帧有效，但为 "空"。
   注2：解压大小是一个可选的字段，它可能不存在，通常在数据流模式下。
            当 `return == ZSTD_CONTENTSIZE_UNKNOWN` 时，要解压的数据可以是任何大小。
            在这种情况下，就需要使用数据流模式来解压数据。也可以选择，应用程序可以依靠一些隐含的限制。
            因为 ZSTD_decompress() 只需要一个解压大小的上界。(例如，数据可以一定被切成 <= 16 KB的块)。
   注3：当使用单通道函数完成压缩时，解压大小总是存在的。
            如 ZSTD_compress()、ZSTD_compressCCtx() ZSTD_compress_usingDict() 或 ZSTD_compress_usingCDict()。
   注4：解压后的大小可能会非常大(64-bits的值)。
            潜在地大于本地系统所能处理的单个内存段。
            在这种情况下，就需要使用数据流模式来解压数据。
   注5：如果源是不受信任的，解压大小可能是错误的，或者是故意修改的。
            始终确保返回值符合应用程序的授权限制。每个应用程序可以设置自己的限制。
   注6：这个函数取代了 ZSTD_getDecompressedSize()。
</p></pre><BR>

<pre><b>unsigned long long ZSTD_getDecompressedSize(const void* src, size_t srcSize);
</b><p>  注意：这个函数现在已经过时了，取而代之的是ZSTD_getFrameContentSize()。
  两个函数的工作方式相同，但是 ZSTD_getDecompressedSize() 混合了
  "空"、"未知 "和 "错误 "的结果是相同的返回值（0）。
  而 ZSTD_getFrameContentSize() 则给它们单独的返回值。
  @return : `src`帧内容的解压大小 _如果已知且不为空_，否则为 0。
</p></pre><BR>

<pre><b>size_t ZSTD_findFrameCompressedSize(const void* src, size_t srcSize);
</b><p>  `src`应指向一个 ZSTD 帧或可跳过帧的开始。
  `srcSize`必须 >= 第一个帧的大小。
  @return：从`src`开始的第一帧的压缩大小。
          适合作为 `srcSize' 传递给 `ZSTD_decompress' 或类似产品。
          如果输入无效，则显示错误代码
</p></pre><BR>

<h3>辅助函数</h3><pre></pre><b><pre>#define ZSTD_COMPRESSBOUND(srcSize)   ((srcSize) + ((srcSize)>>8) + (((srcSize) < (128<<10)) ? (((128<<10) - (srcSize)) >> 11) : 0))</b>
                                                  /* 只要 A 和 B >= 128KB 该公式确保 bound(A) + bound(B) <= bound(A+B) */<b>
size_t      ZSTD_compressBound(size_t srcSize); </b>/*!< 在最差情况下，单次最大压缩大小 */<b>
unsigned    ZSTD_isError(size_t code);          </b>/*!< 判断函数返回结果 `size_t` 是否为错误代码 */<b>
const char* ZSTD_getErrorName(size_t code);     </b>/*!< 从错误代码中提供可读字符串 */<b>
int         ZSTD_minCLevel(void);               </b>/*!< 允许的最小负压缩水平 */<b>
int         ZSTD_maxCLevel(void);               </b>/*!< 最大可用压缩级别 */<b>
</pre></b><BR>
<a name="Chapter4"></a><h2>明确上下文</h2><pre></pre>

<h3>压缩上下文</h3><pre>  当压缩多次，建议只分配一次上下文，
  并在每次连续的压缩操作中重新使用它，这将使工作负载对系统的内存更友好。
  注意1：重新使用上下文只是一种速度/资源优化，它不会改变压缩率，压缩率保持不变。
  注意2：在多线程环境下，每个线程使用一个不同的上下文进行并行执行。

</pre><b><pre>typedef struct ZSTD_CCtx_s ZSTD_CCtx;
ZSTD_CCtx* ZSTD_createCCtx(void);
size_t     ZSTD_freeCCtx(ZSTD_CCtx* cctx);
</pre></b><BR>
<pre><b>size_t ZSTD_compressCCtx(ZSTD_CCtx* cctx,
                         void* dst, size_t dstCapacity,
                   const void* src, size_t srcSize,
                         int compressionLevel);
</b><p>  和 ZSTD_compress() 一样，使用一个显式的 ZSTD_CCtx
  重要的是：为了与 `ZSTD_compress()` 表现相似
  该函数按要求的压缩级别进行压缩
  __忽略任何其他参数__
  如果使用高级API设置了任何高级参数
  它们都将被重置，只有 `compressionLevel` 会被保留
</p></pre><BR>

<h3>解压上下文</h3><pre>  当解压多次，建议一个上下文只分配一次。
  并在每次连续的压缩操作中重新使用它。
  这将使工作负载对系统的内存更友好。
  每个线程使用一个上下文进行并行执行。
</pre><b><pre>typedef struct ZSTD_DCtx_s ZSTD_DCtx;
ZSTD_DCtx* ZSTD_createDCtx(void);
size_t     ZSTD_freeDCtx(ZSTD_DCtx* dctx);
</pre></b><BR>
<pre><b>size_t ZSTD_decompressDCtx(ZSTD_DCtx* dctx,
                           void* dst, size_t dstCapacity,
                     const void* src, size_t srcSize);
</b><p>  与 ZSTD_decompress() 相同，
  需要分配一个 ZSTD_DCtx，与粘性参数兼容
</p></pre><BR>

<a name="Chapter5"></a><h2>高级压缩 API</h2><pre></pre>

<pre><b>typedef enum { ZSTD_fast=1,
               ZSTD_dfast=2,
               ZSTD_greedy=3,
               ZSTD_lazy=4,
               ZSTD_lazy2=5,
               ZSTD_btlazy2=6,
               ZSTD_btopt=7,
               ZSTD_btultra=8,
               ZSTD_btultra2=9
               </b>/* 注：未来可能会增加新的策略，只保证顺序（从快到强） */<b>
} ZSTD_strategy;
</b></pre><BR>
<pre><b>typedef enum {

    </b>/* 压缩 ZSTD_compressionParameters (压缩参数)
     * 注意：当使用 ZSTD_CDict 压缩时，这些参数将被取代
     * 由用于构造 ZSTD_CDict 的参数决定
     * 更多信息请参见 ZSTD_CCtx_refCDict() (superseded-by-cdict). */<b>
    ZSTD_c_compressionLevel=100,</b>/* 根据预先定义的 cLevel 表设置压缩参数
                                  * 注意，确切的压缩参数是动态确定的
                                  * 取决于压缩级别和 srcSize（已知时）
                                  * 默认级别是 ZSTD_CLEVEL_DEFAULT==3
                                  * 特殊情况：值 0 表示默认，由 ZSTD_CLEVEL_DEFAULT 控制
                                  * 注1 : 可以通过负压缩级别
                                  * 注2 : 设置一个级别并不会自动设置所有其他压缩参数
                                  *   设置为默认值。 但是，设置这个等级最终会动态地影响那些没有手动设置的压缩参数
                                  *   手动设置的那些会 'stick' */
    /* 高级压缩参数 :
     * 可以将压缩参数固定为一些特定的值，在这种情况下，压缩器不再动态地选择这些值 */<b>
    ZSTD_c_windowLog=101,   </b>/* 允许的最大反向参考距离，用2的幂表示
                              * 这将设置数据流解压缩的内存预算,
                              * 较大的数值需要更多的内存，而且通常压缩得更多
                              * 必须控制在 ZSTD_WINDOWLOG_MIN 和ZSTD_WINDOWLOG_MAX 之间
                              * 特殊：值 0 表示 "使用默认的 windowLog"
                              * 注意：使用大于 ZSTD_WINDOWLOG_LIMIT_DEFAULT 的 windowLog
                              *       需要在数据流解压缩阶段明确允许这种大小 */<b>
    ZSTD_c_hashLog=102,
                             </b>/* 初始探测表的大小，为2的幂
                              * 结果内存使用量为 (1 << (hashLog+2))
                              * 必须介于 ZSTD_HASHLOG_MIN 和 ZSTD_HASHLOG_MAX之间
                              * 较大的表可以提高策略的压缩比 <= dFast,
                              * 并提高策略的速度 > dFast
                              * 特别：值 0 表示 "使用默认的 hashLog" */<b>
    ZSTD_c_chainLog=103,    </b>/* 多探针搜索表的大小，2的幂。
                              * 结果内存使用量为 (1 << (chainLog+2))
                              * 必须介于 ZSTD_CHAINLOG_MIN 和ZSTD_CHAINLOG_MAX 之间
                              * 表越大，压缩效果越好，速度越慢
                              * 这个参数对于 "fast" 策略是没有用的
                              * 当使用 "dfast" 策略时，这个参数仍然有用
                              * 在这种情况下，它定义了一个二级探针表。
                              * 特别：值 0 表示 "使用默认的 chainLog" */<b>
    ZSTD_c_searchLog=104,   </b>/* 搜索尝试的次数，是2的幂
                              * 尝试次数越多，压缩效果越好，速度越慢
                              * 这个参数对于 "fast" 和 "dFast" 策略没有用
                              * 特殊：值 0 表示 "使用默认的 searchLog" */<b>
    ZSTD_c_minMatch=105,    </b>/* 搜索到的匹配项的最小尺寸
                              * 注意，Zstandard 仍然可以找到较小尺寸的匹配
                              * 它只是调整其搜索算法来寻找这个尺寸和更大的尺寸
                              * 较大的值会增加压缩和解压速度，但会降低比率
                              * 必须介于 ZSTD_MINMATCH_MIN 和ZSTD_MINMATCH_MAX 之间
                              * 注意，目前对于所有策略 < btopt，有效最小值为 4
                              * 对于所有 > fast 的策略，有效的最大值是 6
                              * 特殊：值 0 表示 "使用默认的 minMatchLength" */<b>
    ZSTD_c_targetLength=106,</b>/* 该字段的影响取决于策略
                              * 对于策略 btop、btultra 和 btultra2：
                              *     匹配的长度被认为 "足够好" 而停止搜索.
                              *     值越大，压缩越强，速度越慢
                              * 对于 fast 策略：
                              *     匹配采样之间的距离
                              *     值越大，压缩越快，比率越小
                              * 特殊：值 0 表示 "使用默认的targetLength" */<b>
    ZSTD_c_strategy=107,    </b>/* 参见 ZSTD_strategy 枚举定义
                              * 所选策略的值越高，越复杂
                              * 导致压缩更强，速度更慢
                              * 特别：值 0 表示 "使用默认 strategy" */<b>
    
    </b>/* LDM 模式参数 */<b>
    ZSTD_c_enableLongDistanceMatching=160,
                             </b>/* 启用长距离匹配
                              * 此参数是为了提高压缩比而设计的
                              * 对于大的输入，通过在远距离寻找大的匹配
                              * 它增加了内存使用和窗口大小
                              * 注意：启用该参数会使默认的 ZSTD_c_windowLog 增加到128 MB
                              * 除非明确设置了不同的值
                              * 注意：如果 ZSTD_c_windowLog >= 128 MB 且
                              * 压缩策略 >= ZSTD_btopt (压缩级别16+)，则默认启用 */<b>
    ZSTD_c_ldmHashLog=161,  </b>/* 长距离匹配表的大小，为2的幂
                              * 值越大，内存使用量和压缩比率越大
                              * 但会降低压缩速度
                              * 必须介于 ZSTD_HASHLOG_MIN和ZSTD_HASHLOG_MAX 之间
                              * 默认：windowlog - 7。
                              * 特殊：值 0 表示 "自动确定 hashlog" */<b>
    ZSTD_c_ldmMinMatch=162, </b>/* 长距离匹配的最小匹配大小
                              * 太大或太小的值通常会降低压缩比率
                              * 必须介于 ZSTD_LDM_MINMATCH_MIN 和 ZSTD_LDM_MINMATCH_MAX 之间
                              * 特殊：值 0 表示 "使用默认值"（默认值：64） */<b>
    ZSTD_c_ldmBucketSizeLog=163,
                             </b>/* LDM 哈希表中每个 Bucket 的对数大小，用于解决碰撞问题
                              * 较大的值可以提高碰撞分辨率，但会降低压缩速度
                              * 最大值是 ZSTD_LDM_BUCKETSIZELOG_MAX
                              * 特殊：值 0 表示 "使用默认值"（默认值：3） */<b>
    ZSTD_c_ldmHashRateLog=164,
                             </b>/* 在 LDM 哈希表中插入 / 查找条目的频率
                              * 必须介于 0 和 (ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN).
                              * 默认值是 MAX(0, (windowLog - ldmHashLog))，优化哈希表的使用
                              * 值越大，压缩速度越快
                              * 如果远远偏离默认值，很可能会导致压缩率下降
                              * 特殊：值 0 表示 "自动确定hashRateLog" */<b>
    
    </b>/* 帧参数 */<b>
    ZSTD_c_contentSizeFlag=200,
                             </b>/* 内容大小将被写入帧头 _whenever known_ (默认:1)
                              * 内容大小必须在压缩开始时就知道
                              * 当使用 ZSTD_compress2() 时，会自动知道内容大小
                              * 对于数据流方案，必须用ZSTD_CCtx_setPledgedSrcSize() 提供内容大小 */<b>
    ZSTD_c_checksumFlag=201,</b>/* 32-bits 的内容校验和被写入到帧尾（默认：0） */<b>
    ZSTD_c_dictIDFlag=202,  </b>/* 当适用时，字典的ID被写入帧头（默认：1） */<b>
    
    </b>/* 多线程参数 */<b>
    </b>/* 这些参数只有在启用多线程的情况下才会被激活（用编译宏 ZSTD_MULTITHREAD 编译）
     * 否则，试图设置默认值 (0) 以外的任何其他值都是不可能的，并返回一个错误
     * 在不知道链接库是否支持多线程的情况下
     * 将 ZSTD_c_nbWorkers 设置为任何 >=1 的值，并查看返回值，可以快速检查该属性
     */<b>
    ZSTD_c_nbWorkers=400,   </b>/* 选择产生多少个线程来并行压缩
                              * 当 nbWorkers >= 1 时，当调用 ZSTD_compressStream*() 时触发异步模式
                              * ZSTD_compressStream*() 会消耗输入并尽可能地刷新输出，但会立即将控制权还给调用者
                              * 而压缩是在工作线程中并行进行的
                              * (注意：这个规则的一个强烈的例外是当第一次调用ZSTD_compressStream2() 设置 ZSTD_e_end 时
                              * 在这种情况下，ZSTD_compressStream2()  委托给 ZSTD_compress2()，而 ZSTD_compress2() 总是一个阻塞调用）
                              * 更多的 workers 提高了速度，但也增加了内存使用量
                              * 默认值是 `0`，也就是 "单线程模式"：不产生任何 worker
                              * 压缩是在 Caller 的线程中进行的，所有的调用都是阻塞的 */<b>
    ZSTD_c_jobSize=401,     </b>/* 压缩作业的大小，只有当 nbWorkers >= 1 时，这个值才会被强制执行
                              * 每个压缩作业都是并行完成的，所以这个值会间接影响活动线程的数量。
                              * 0 表示默认值，该值根据压缩参数动态确定
                              * 作业大小必须是重叠大小的最小值，或 1MB，以最大值为准
                              * 最小尺寸是自动透明地执行的 */<b>
    ZSTD_c_overlapLog=402,  </b>/* 控制重叠大小，作为窗口大小的一部分
                              * 重叠大小是指在新作业开始时，从上一个作业重新加载的数据量
                              * 当每个作业被并行压缩时，它有助于保持压缩率
                              * 该值仅在 nbWorkers >= 1 时执行
                              * 该值越大，压缩比率越高，但速度越低
                              * 可能的值范围是0到9：
                              * - 0 表示 "默认值"：该值将由库决定，取决于策略
                              * - 1 表示 "无重叠"。
                              * - 9 表示 "完全重叠"，使用全窗口大小。
                              * 每一个中间等级增加/减少一个系数2的负荷大小。
                              * 9：全窗口；8：w/2；7：w/4；6：w/8；5：w/16；4：w/32；3：w/64；2：w/128；1：无重叠；0：默认
                              * 默认值在6和9之间，取决于策略 */<b>
    
    </b>/* 注意：也可提供其他实验参数
     * 在API的实验部分
     * 在编写本报告时，它们包括 :
     * ZSTD_c_rsyncable
     * ZSTD_c_format
     * ZSTD_c_forceMaxWindow
     * ZSTD_c_forceAttachDict
     * ZSTD_c_literalCompressionMode
     * ZSTD_c_targetCBlockSize
     * ZSTD_c_srcSizeHint
     * ZSTD_c_enableDedicatedDictSearch
     * ZSTD_c_stableInBuffer
     * ZSTD_c_stableOutBuffer
     * ZSTD_c_blockDelimiters
     * ZSTD_c_validateSequences
     * 因为它们不稳定，所以需要定义ZSTD_STATIC_LINKING_ONLY 来访问它们
     * 注意：千万不要直接使用 experimentalParam 的名字
     *      另外，枚举值本身也是不稳定的，仍然可能改变
     */<b>
     ZSTD_c_experimentalParam1=500,
     ZSTD_c_experimentalParam2=10,
     ZSTD_c_experimentalParam3=1000,
     ZSTD_c_experimentalParam4=1001,
     ZSTD_c_experimentalParam5=1002,
     ZSTD_c_experimentalParam6=1003,
     ZSTD_c_experimentalParam7=1004,
     ZSTD_c_experimentalParam8=1005,
     ZSTD_c_experimentalParam9=1006,
     ZSTD_c_experimentalParam10=1007,
     ZSTD_c_experimentalParam11=1008,
     ZSTD_c_experimentalParam12=1009
} ZSTD_cParameter;
</b></pre><BR>
<pre><b>typedef struct {
    size_t error;
    int lowerBound;
    int upperBound;
} ZSTD_bounds;
</b></pre><BR>
<pre><b>ZSTD_bounds ZSTD_cParam_getBounds(ZSTD_cParameter cParam);
</b><p>  所有参数必须属于一个有下限和上限的区间，否则它们会触发一个错误或被自动夹紧
  @return : 一个 ZSTD_bounds 结构体，其中包含了
         - 一个错误状态字段，必须使用 ZSTD_isError() 测试
         - 下限和上限，包括在内
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_setParameter(ZSTD_CCtx* cctx, ZSTD_cParameter param, int value);
</b><p>  设置一个压缩参数，由 enum ZSTD_cParameter 选择
  所有的参数都具有有效的边界，可以使用 ZSTD_cParam_getBounds() 查询边界
  提供一个超出边界的值将会限制它，或者触发一个错误（取决于参数）
  一般来说，只有在帧初始化的时候（开始压缩之前）才可以设置参数
  例外情况：当使用多线程模式时（nbWorkers >= 1）
              以下参数可以在压缩过程中更新（在同一帧内）
              => 压缩级别、哈希值、链值、搜索值、minMatch、目标长度和策略
              新的参数只在下一个作业中有效（在 flush() 之后）
 @return : 一个错误代码 (可以使用 ZSTD_isError() 来测试)
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_setPledgedSrcSize(ZSTD_CCtx* cctx, unsigned long long pledgedSrcSize);
</b><p>  要压缩成单帧的总输入数据大小
  该值将被写入帧头，除非使用 ZSTD_c_contentSizeFlag 明确禁止
  这个值也会在帧结束时被控制，如果不被遵守，会触发一个错误
 @result : 0，或者一个错误代码 (可以用 ZSTD_isError() 测试)
  注1 : pledgedSrcSize==0 实际上意味着 0，也就是一个空帧
           为了表示 "未知内容大小"，传递常量 ZSTD_CONTENTSIZE_UNKNOWN
           ZSTD_CONTENTSIZE_UNKNOWN 是任何新帧的默认值
  注2 : pledgedSrcSize 只对下一帧有效一次
           它在帧结束时被丢弃，并由 ZSTD_CONTENTSIZE_UNKNOWN 代替
  注3 : 每当所有的输入数据在一个回合内提供和消耗时
           例如使用 ZSTD_compress2()
           或立即调用 ZSTD_compressStream2(,,ZSTD_e_end)。
           这个值会自动被 srcSize 覆盖
</p></pre><BR>

<pre><b>typedef enum {
    ZSTD_reset_session_only = 1,
    ZSTD_reset_parameters = 2,
    ZSTD_reset_session_and_parameters = 3
} ZSTD_ResetDirective;
</b></pre><BR>
<pre><b>size_t ZSTD_CCtx_reset(ZSTD_CCtx* cctx, ZSTD_ResetDirective reset);
</b><p>  有2种不同的东西可以被重置，独立或联合：
  - 会话：将停止压缩当前帧，并使 CCtx 准备开始一个新的帧
          在出错后很有用，或者中断任何正在进行的压缩
          任何尚未刷新的内部数据都会被取消
          压缩参数和字典保持不变
          它们将被用于压缩下一帧
          重置会话永远不会失败
  - 参数：将所有参数恢复到 "默认值"
          这也会删除对任何字典的引用
          参数只能在两个会话之间更改（即当前没有进行压缩）
          否则复位失败，函数返回一个错误值(可以使用 ZSTD_isError() 来测试)
  - 两者：类似于重置会话，然后重置参数
</p></pre><BR>

<pre><b>size_t ZSTD_compress2( ZSTD_CCtx* cctx,
                       void* dst, size_t dstCapacity,
                 const void* src, size_t srcSize);
</b><p>  与 ZSTD_compressCCtx() 的行为相同，但压缩参数是用高级API设置的
  ZSTD_compress2() 总是开始一个新的帧
  如果 cctx 保存了之前未完成的帧的数据，那么关于它的一切都会被遗忘
  - 在开始压缩之前，压缩参数会被推送到 CCtx 中，使用ZSTD_CCtx_set*()
  - 该函数始终处于阻塞状态，压缩完成后返回
  提示：如果 `dstCapacity`>= `ZSTD_compressBound(srcSize)`，压缩运行更快
 @return : 压缩后的大小写入`dst` (<= `dstCapacity)。
           如果失败，则返回一个错误代码（可以使用ZSTD_isError() 来测试）
</p></pre><BR>

<a name="Chapter6"></a><h2>高级解压 API</h2><pre></pre>

<pre><b>typedef enum {

    ZSTD_d_windowLogMax=100,</b>/* 选择一个尺寸限制（以2的幂为单位），超过这个限制，则
                              * 数据流 API 将拒绝分配内存缓冲区
                              * 为了保护主机免受不合理的内存需求
                              * 这个参数只有在数据流模式下才有用，因为在单程模式下没有分配内部缓冲区
                              * 默认情况下，解压上下文接受的窗口大小 <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT)
                              * 特殊：值 0 表示 "使用默认的最大windowLog" */<b>
    
    </b>/* 注意：也可提供其他实验参数
     * 在API的实验部分。
     * 在编写本报告时，它们包括:
     * ZSTD_d_format
     * ZSTD_d_stableOutBuffer
     * ZSTD_d_forceIgnoreChecksum
     * 因为它们不稳定，所以需要定义ZSTD_STATIC_LINKING_ONLY 来访问它们
     * 注意：永远不要直接使用 experimentalParam 的名字
     */<b>
     ZSTD_d_experimentalParam1=1000,
     ZSTD_d_experimentalParam2=1001,
     ZSTD_d_experimentalParam3=1002

} ZSTD_dParameter;
</b></pre><BR>

<pre><b>ZSTD_bounds ZSTD_dParam_getBounds(ZSTD_dParameter dParam);
</b><p>  所有参数必须属于一个有下限和上限的区间
  否则它们会触发一个错误或被自动夹紧
 @return : 一个 ZSTD_bounds 结构体，其中包含了
         - 一个错误状态字段，必须使用 ZSTD_isError() 进行测试
         - 上下限
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_setParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int value);
</b><p>  设置一个压缩参数，由 enum ZSTD_dParameter 选择
  所有的参数都有有效的边界，可以使用ZSTD_dParam_getBounds() 查询边界
  提供一个超出边界的值将会限制它，或者触发一个错误（取决于参数）
  只有在帧初始化时(在开始解压之前)才可以设置一个参数
 返回 : 0，或者一个错误代码(可以用 ZSTD_isError() 来测试)
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_reset(ZSTD_DCtx* dctx, ZSTD_ResetDirective reset);
</b><p>  重置 DCtx 到干净状态
  会话和参数可以联合或单独复位
  只有当没有活动帧被解压时，参数才能被重置
 返回 : 0，或者一个错误代码，可以用 ZSTD_isError() 测试
</p></pre><BR>

<a name="Chapter7"></a><h2>数据流</h2><pre></pre>

<pre><b>typedef struct ZSTD_inBuffer_s {
  const void* src;    </b>/**< 输入缓冲区的开始 */<b>
  size_t size;        </b>/**< 输入缓冲区的大小 */<b>
  size_t pos;         </b>/**< 读取停止的位置，会被更新。必然是 0 <= pos <= size */<b>
} ZSTD_inBuffer;
</b></pre><BR>
<pre><b>typedef struct ZSTD_outBuffer_s {
  void*  dst;         </b>/**< 输出缓冲区的开始 */<b>
  size_t size;        </b>/**< 输出缓冲区的大小 */<b>
  size_t pos;         </b>/**< 写入停止的位置，会被更新。必然是 0 <= pos <= size */<b>
} ZSTD_outBuffer;
</b></pre><BR>
<a name="Chapter8"></a><h2>数据流压缩 - HowTo</h2><pre>
  需要一个 ZSTD_CStream 对象来跟踪数据流操作
  使用 ZSTD_createCStream() 和 ZSTD_freeCStream() 来创建/释放资源
  ZSTD_CStream 对象可以在连续的压缩操作中重复使用多次
  建议重复使用 ZSTD_CStream，因为它可以重复使用已经分配的内存，从而更好地利用系统的内存

  对于并行执行，每个线程使用一个单独的ZSTD_CStream

  注意：从v1.3.0开始，ZSTD_CStream 和 ZSTD_CCtx 是一回事

  参数是粘性的：当在同一上下文上启动新的压缩时
  它将重新使用与之前压缩会话相同的粘性参数
  当有疑问时，建议在使用前完全初始化上下文
  使用 ZSTD_CCtx_reset() 和 ZSTD_CCtx_setParameter() 来重置上下文
  ZSTD_CCtx_setPledgedSrcSize()，或 ZSTD_CCtx_loadDictionary()
  和其他函数设置更具体的参数，保证源大小，或者加载字典

  使用 ZSTD_compressStream2() 与 ZSTD_e_continue 进行必要的多次操作，以达到以下目的
  消耗输入流，该函数将自动更新 "pos" 和 "input" 和 "output" 中的字段
  请注意，该函数可能不会消耗整个输入，例如：
  因输出缓冲区已经满了，在这种情况下，`input.pos < input.size`
  调用者必须检查输入是否已经全部消耗完毕
  如果没有，调用者必须腾出一些空间来接收更多的压缩数据
  然后再呈现剩余的输入数据
   注意：ZSTD_e_continue 被调用时，保证会有一定的前进速度
        但并不能保证最大限度的向前发展，这一点尤为重要
        这一点在使用多个线程进行压缩时尤为重要
        如果能消耗一些输入，调用不会阻塞
        但如果不能，它将等待一些（但不是全部）输出被刷新
  @return : 提供了从内部缓冲区刷新数据的最小剩余量，
           或错误代码，可以使用 ZSTD_isError() 进行测试

  在任何时候，它都有可能冲洗任何可能停留在内部缓冲区的数据
  使用 ZSTD_compressStream2() 和 ZSTD_e_flush`output->pos` 将被更新
  注意，如果 `output->size` 太小，用 ZSTD_e_flush 调用一次可能就不够了(返回代码>0)
  在这种情况下，腾出一些空间来接收更多的压缩数据，然后用 ZSTD_e_flush 再次调用 ZSTD_compressStream2()
  你必须继续用 ZSTD_e_flush 调用ZSTD_compressStream2()，直到它返回 0，这时你可以改变运作
  注意：ZSTD_e_flush 会尽可能多地刷新输出，这意味着当使用多线程压缩时，它会阻塞，直到刷新完成或输出缓冲区满为止
  @return : 如果内部缓冲区完全刷新，则为 0
            >0，如果一些数据仍然存在于内部缓冲区中（该值是剩余大小的最小估计值）
            或错误代码，可以使用 ZSTD_isError() 进行测试

  用 ZSTD_e_end 调用 ZSTD_compressStream2() 指示完成一帧
  它将执行刷新并写入帧尾，这是解码器认为一帧完成所必须的
  flush 操作与调用 ZSTD_compressStream2() 和 ZSTD_e_flush 的规则是一样的
  你必须继续用ZSTD_e_end 调用 ZSTD_compressStream2()，直到它返回0，这时你可以自由地开始一个新的帧
  注意 : ZSTD_e_end 会尽可能多地刷新输出，这意味着当使用多线程压缩时，它会阻塞，直到刷新完成或输出缓冲区满为止
  @return : 如果帧完全完成并完全刷新，则返回 0
            >0，如果一些数据仍然存在于内部缓冲区中（该值是剩余大小的最小估计值）
            或错误代码，可以使用 ZSTD_isError() 进行测试.


<BR></pre>

<pre><b>typedef ZSTD_CCtx ZSTD_CStream;  </b>/**< CCtx 和 CStream 现在实际上是同一个对象 (>= v1.3.0) */<b>
</b></pre><BR>
<h3>ZSTD_CStream 管理函数</h3><pre></pre><b><pre>ZSTD_CStream* ZSTD_createCStream(void);
size_t ZSTD_freeCStream(ZSTD_CStream* zcs);
</pre></b><BR>
<h3>数据流压缩函数</h3><pre></pre><b><pre>typedef enum {
    ZSTD_e_continue=0, </b>/* 编码器收集更多的数据，决定何时输出压缩结果，以达到最佳的压缩比 */<b>
    ZSTD_e_flush=1,    </b>/* 刷新目前提供的所有数据。
                        * 它创建了（至少）一个新的块，可以在接收时立即解码
                        * 帧将继续：任何未来的数据仍然可以引用以前压缩的数据，提高压缩比率
                        * 注意：多线程压缩会块化，以尽可能多的刷新输出 */<b>
    ZSTD_e_end=2       </b>/* 刷新任何剩余的数据，并关闭当前帧
                        * 注意，只有在压缩数据完全刷新后，才会关闭帧（返回值==0）
                        * 在这之后，任何额外的数据都会开始一个新的帧
                        * 注意：每个帧都是独立的（不引用前一帧的任何内容）
                        * 注意：多线程压缩会阻塞，以尽可能多地刷新输出 */<b>
} ZSTD_EndDirective;
</pre></b><BR>
<pre><b>size_t ZSTD_compressStream2( ZSTD_CCtx* cctx,
                             ZSTD_outBuffer* output,
                             ZSTD_inBuffer* input,
                             ZSTD_EndDirective endOp);
</b><p>  与 ZSTD_compressStream 的行为大致相同，但增加了对结束指令的控制
  - 在开始压缩之前，使用 ZSTD_CCtx_set*() 将压缩参数推送到 CCtx 中
  - 一旦开始压缩，压缩参数就无法更改（在多线程模式下保存异常列表）
  - output->pos 必须 <= dstCapacity，input->pos 必须 <= srcSize
  - output->pos 和 input->pos 将被更新，它们被保证保持在各自的极限之下
  - endOp 必须是一个有效的指令
  - 当 nbWorkers==0（默认）时，函数是阻塞的：它在返回调用者之前完成工作
  - 当 nbWorkers>=1 时，函数是非阻塞的：它复制一部分输入，将工作分配给内部工作线程，并刷新输出任何可用的东西
            然后立即返回，只是表示还有一些数据需要刷新
            不过，该函数还是保证了前进的进度：它只有在读或写了至少1个以上的字节后才会返回
  - 异常：如果第一次调用请求 ZSTD_e_end 指令并提供了足够的 dstCapacity，则函数委托给 ZSTD_compress2()，而 ZSTD_compress2() 总是阻塞的
  - @return 提供了从内部缓冲区刷新的最小剩余数据量
            或一个错误代码，可以使用 ZSTD_isError() 来测试
            如果 @return != 0，则说明刷新没有完全完成，内部缓冲区中还有一些数据
            这对于 ZSTD_e_flush 是很有用的，因为在这种情况下，需要更多的刷新来清空所有的缓冲区
            对于 ZSTD_e_end，当内部缓冲区完全刷新且帧完成时，@return == 0
  - 在 ZSTD_e_end 指令后，如果内部缓冲区没有完全刷新(@return !=0)
            只有 ZSTD_e_end 或 ZSTD_e_flush 操作是允许的
            在开始一个新的压缩作业，或改变压缩参数之前
            它是需要完全刷新内部缓冲区的
</p></pre><BR>

<pre><b>size_t ZSTD_CStreamInSize(void);    </b>/**< 输入缓冲区的推荐大小 */<b>
</b></pre><BR>
<pre><b>size_t ZSTD_CStreamOutSize(void);   </b>/**< 输出缓冲区的推荐大小，保证至少成功刷新一个完整的压缩块 */<b>
</b></pre><BR>
<pre><b>size_t ZSTD_initCStream(ZSTD_CStream* zcs, int compressionLevel);
</b>/*!
 * ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue) 的替代方案。
 * 注意：返回值不同。ZSTD_compressStream() 会返回一个提示值，用于提示 ZSTD_compressStream2(zcs, output, input)
 * 下一次读取的大小(如果非零且不出错) ZSTD_compressStream2()
 * 返回剩余的最小字节数（如果不为零且不出错）
 */<b>
size_t ZSTD_compressStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output, ZSTD_inBuffer* input);
</b>/*! 相当于 ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush). */<b>
size_t ZSTD_flushStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);
</b>/*! 相当于 ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end). */<b>
size_t ZSTD_endStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);
</b><p>
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_refCDict(zcs, NULL); // 清空字典(如果有的话)
     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
</p></pre><BR>

<a name="Chapter9"></a><h2>数据流解压 - HowTo</h2><pre>
  需要一个 ZSTD_DStream 对象来跟踪数据流操作
  使用 ZSTD_createDStream() 和 ZSTD_freeDStream() 来创建/释放资源
  ZSTD_DStream 对象可以被多次重复使用

  使用 ZSTD_initDStream() 开始一个新的解压操作
 @return : 推荐的第一个输入大小
  或者，使用高级 API 来设置特定的属性

  重复使用 ZSTD_decompressStream() 来消耗你的输入
  该函数将更新两个`pos` 字段。
  如果 `input.pos < input.size`，则说明有些输入没有被消耗掉
  剩余的数据要由调用者再次呈现
  该函数试图在尊重输出缓冲区大小的前提下，立即刷新所有解码的数据
  如果 `output.pos < output.size`，解码器已经刷新了所有能刷新的数据
  但如果 `output.pos == output.size`，内部缓冲区可能还有一些数据......
  在这种情况下，再次调用 ZSTD_decompressStream() 来刷新缓冲区中的剩余数据
  注意：在没有额外输入的情况下，刷新的数据量一定是 <= ZSTD_BLOCKSIZE_MAX
 @return : 当一帧完全解码并完全刷新时，返回 0
        或错误代码，可以使用 ZSTD_isError() 进行测试
        或任何其他大于 0 的值，这意味着还有一些解码或刷新工作要做，以完成当前帧
        返回值是一个建议的下一个输入大小（只是一个提示，以获得更好的延迟
        将永远不会请求超过剩余的帧大小

<BR></pre>

<pre><b>typedef ZSTD_DCtx ZSTD_DStream;  </b>/**< CCtx 和 CStream 现在实际上是同一个对象 (>= v1.3.0) */<b>
</b></pre><BR>
<h3>ZSTD_DStream 管理函数</h3><pre></pre><b><pre>ZSTD_DStream* ZSTD_createDStream(void);
size_t ZSTD_freeDStream(ZSTD_DStream* zds);
</pre></b><BR>
<h3>数据流压缩函数</h3><pre></pre><b><pre></pre></b><BR>
<pre><b>size_t ZSTD_DStreamInSize(void);    </b>/*!< 输入缓冲区的推荐大小 */<b>
</b></pre><BR>
<pre><b>size_t ZSTD_DStreamOutSize(void);   </b>/*!< 输出缓冲区的推荐大小，保证在任何情况下都能成功刷新至少一个完整的块 */<b>
</b></pre><BR>
<a name="Chapter10"></a><h2>简单字典 API</h2><pre></pre>

<pre><b>size_t ZSTD_compress_usingDict(ZSTD_CCtx* ctx,
                               void* dst, size_t dstCapacity,
                         const void* src, size_t srcSize,
                         const void* dict,size_t dictSize,
                               int compressionLevel);
</b><p>  使用字典进行显式压缩
  字典可以是任何任意的数据段（也称为前缀）
  或包含指定信息的缓冲区(参见 dictBuilder/zdict.h)
  注意：这个函数加载字典，导致明显的启动延迟
       它的目的是用于只使用一次的字典
  注意：当`dict == NULL || dictSize < 8`时，不使用字典
</p></pre><BR>

<pre><b>size_t ZSTD_decompress_usingDict(ZSTD_DCtx* dctx,
                                 void* dst, size_t dstCapacity,
                           const void* src, size_t srcSize,
                           const void* dict,size_t dictSize);
</b><p>  使用已知的字典进行解压
  字典必须与压缩时使用的字典相同
  注意：这个函数会加载字典，导致明显的启动延迟
       它的目的是用于只使用一次的字典
  注意：当`dict == NULL || dictSize < 8`时，不使用字典
</p></pre><BR>

<a name="Chapter11"></a><h2>批量处理字典 API</h2><pre></pre>

<pre><b>ZSTD_CDict* ZSTD_createCDict(const void* dictBuffer, size_t dictSize,
                             int compressionLevel);
</b><p>  当使用同一字典压缩多个消息或块时
  建议只消化一次字典，因为这是一个消耗很大的操作
  ZSTD_createCDict() 将从消化一个字典中创建一个状态
  所产生的状态可以用于未来的压缩操作，启动成本非常有限
  ZSTD_CDict 可以创建一次，并由多个线程并发共享，因为它的用法是只读
  @dictBuffer 可以在 ZSTD_CDict 创建后释放，因为它的内容是复制在 CDict 中的
  注意1：如果你不想重复 @dictBuffer 的内容，可以考虑实验性的函数`ZSTD_createCDict_byReference()`
  注意2：一个 ZSTD_CDict 可以从一个空的 @dictBuffer 创建
      在这种情况下，它唯一传输的是 @compressionLevel
      这在专门使用 ZSTD_compress_usingCDict() 的流程中很有用
      期待一个包含任何数据的 ZSTD_CDict 参数，包括那些没有已知字典的数据
</p></pre><BR>

<pre><b>size_t      ZSTD_freeCDict(ZSTD_CDict* CDict);
</b><p>  函数释放 ZSTD_createCDict() 分配的内存
</p></pre><BR>

<pre><b>size_t ZSTD_compress_usingCDict(ZSTD_CCtx* cctx,
                                void* dst, size_t dstCapacity,
                          const void* src, size_t srcSize,
                          const ZSTD_CDict* cdict);
</b><p>  使用消化后的字典进行压缩
  当同一字典被多次使用时，推荐使用
  注意：压缩级别是在 _字典创建时决定的_
       和帧参数是硬编码的 (dictID=yes, contentSize=yes, checksum=no)
</p></pre><BR>

<pre><b>ZSTD_DDict* ZSTD_createDDict(const void* dictBuffer, size_t dictSize);
</b><p>  创建一个消化后的字典，准备开始解压操作，没有启动延迟
  dictBuffer 可以在创建 DDict 后释放，因为它的内容被复制到 DDict 内部
</p></pre><BR>

<pre><b>size_t      ZSTD_freeDDict(ZSTD_DDict* ddict);
</b><p>  函数释放用 ZSTD_createDDict() 分配的内存
</p></pre><BR>

<pre><b>size_t ZSTD_decompress_usingDDict(ZSTD_DCtx* dctx,
                                  void* dst, size_t dstCapacity,
                            const void* src, size_t srcSize,
                            const ZSTD_DDict* ddict);
</b><p>  使用消化后的字典进行解压
  如果多次使用同一字典，建议使用
</p></pre><BR>

<a name="Chapter12"></a><h2>字典辅助函数</h2><pre></pre>

<pre><b>unsigned ZSTD_getDictID_fromDict(const void* dict, size_t dictSize);
</b><p>  提供存储在字典中的 dictID
  如果 @return == 0，则该字典不符合 Zstandard 规范
  它仍然可以被加载，但只是作为一个纯内容的字典
</p></pre><BR>

<pre><b>unsigned ZSTD_getDictID_fromDDict(const ZSTD_DDict* ddict);
</b><p>  提供加载到 "ddict" 中的字典的 dictID
  如果 @return == 0，表示该字典不符合 Zstandard 规范，或为空
  不符合标准的字典仍然可以被加载，但只作为内容字典
</p></pre><BR>

<pre><b>unsigned ZSTD_getDictID_fromFrame(const void* src, size_t srcSize);
</b><p>  提供解压存储在 "src" 中的帧所需的 dictID
  如果 @return == 0，则 dictID 不能被解压
  这可能是由于以下原因之一
  - 帧不需要字典来解码（最常见的情况）
  - 该框架在构建时有意删除了 dictID，无论需要什么字典，都是一个隐藏的信息
    注意：这种用例在使用不符合要求的字典时也会发生
  - `srcSize` 太小了，因此，帧头不能被解码（只有当`srcSize < ZSTD_FRAMEHEADERSIZE_MAX` 时才有可能）
  - 这不是一个 Zstandard 帧
  在确定具体的失败原因时，可以使用 ZSTD_getFrameHeader()，它将提供更精确的错误代码
</p></pre><BR>

<a name="Chapter13"></a><h2>高级字典和前缀 API</h2><pre>
 这个API允许字典与ZSTD_compress2()、ZSTD_compressStream2() 和 ZSTD_decompress() 一起使用
 字典是粘性的，只有用 ZSTD_reset_parameters 或 ZSTD_reset_session_and_parameters 重置上下文
 前缀是一次性使用的
<BR></pre>

<pre><b>size_t ZSTD_CCtx_loadDictionary(ZSTD_CCtx* cctx, const void* dict, size_t dictSize);
</b><p>  从 `dict` 缓冲区创建一个内部 CDict
  解压缩必须使用相同的字典
 @result : 0，或者一个错误代码（可以用 ZSTD_isError() 测试）
   特殊 : 加载一个 NULL (或 0-size) 字典会使之前的字典无效
              意思是 "返回无字典模式"
  注意1 : 字典是粘性的，它将用于以后所有的压缩帧
              要返回到 "无字典 "的情况下，加载一个NULL字典（或重置参数）
  注意2 : 加载字典涉及到建立表
              这也是一个消耗CPU的操作，对延迟的影响不可忽视
              表是依赖于压缩参数的，为此
              压缩参数在加载字典后不能再更改
  注意3 : `dict` 内容将被内部复制
              使用实验性的 ZSTD_CCtx_loadDictionary_byReference() 代替引用内容
              在这种情况下，字典缓冲区必须超过它的用户
  注意4 : 使用 ZSTD_CCtx_loadDictionary_advanced()
              以精确地选择必须如何解释字典内容
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_refCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict);
</b><p>  引用一个准备好的字典，用于所有下一个压缩帧
  请注意，压缩参数是在CDict中执行的
  并取代之前在 CCtx 中设置的任何压缩参数
  在 ZSTD_cParameter 枚举文档中，被忽略的参数被标记为 "superseded-by-cdict"
  如果 CCtx 被返回到无字典模式，被忽略的参数将被再次使用
  该字典在以后使用同一 CCtx 压缩帧时仍然有效
 @result : 0，或者一个错误代码（可以用 ZSTD_isError() 测试）
  特殊：引用一个 NULL 的 CDict 意味着 "返回到无字典模式"
  注1：目前，只能管理一个字典
           引用一个新的字典可以有效地 "丢弃" 任何以前的字典
  注2：CDict 只是被引用，它的寿命必须超过它在 CCtx 中的使用时间
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_refPrefix(ZSTD_CCtx* cctx,
                     const void* prefix, size_t prefixSize);
</b><p>  为下一个压缩帧引用一个前缀（单用途字典）
  一个前缀只被 **使用一次**， 在帧结束时 (ZSTD_e_end) 被丢弃，表在帧结束时 (ZSTD_e_end) 被丢弃
  解压缩将需要相同的前缀来正确地重新生成数据
  使用前缀进行压缩的结果类似于进行差分和压缩
  但执行速度要快得多，尤其是在解压过程中(压缩速度可随压缩级别调整)
 @result : 0，或者一个错误代码（可以用 ZSTD_isError() 测试）
   特殊：添加任何前缀(包括NULL)都会使之前的前缀或字典无效
  注意1：前缀缓冲区是参考的。它 **必须** 比压缩时间长
            它的内容必须在压缩过程中保持不变
  注意2：如果打算将一些大的 src 数据 blob 与自己的某个先前版本进行比较
            确保窗口大小足够大，以包含整个源
            参见 ZSTD_c_windowLog
  注意3：引用一个前缀涉及到建表，这取决于压缩参数
            这是一个消耗CPU的操作，对延迟的影响不可忽视
            如果需要多次使用同一个前缀，可以考虑用loadDictionary代替
  注意4：默认情况下，前缀被解释为原始内容 (ZSTD_dct_rawContent)
            使用实验性的 ZSTD_CCtx_refPrefix_advanced() 来改变字典的解释
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_loadDictionary(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);
</b><p>  从 dict 缓冲区创建一个内部 DDict
  用来解压下一帧
  这个字典对所有未来的帧都是有效的，直到显式失效
 @result : 0，或者一个错误代码（可以用 ZSTD_isError() 测试）
   特殊 : 添加一个 NULL (或0-size) 的字典会使之前的字典无效
              意思是 "返回到无字典模式"
  注意1 : 加载字典涉及到建表
              这对 CPU 的使用率和延迟有着不可忽视的影响
              建议 "一次加载，多次使用"，摊低成本
  注意2 : `dict` 内容会被内部复制，所以 `dict` 加载后可以释放
              使用 ZSTD_DCtx_loadDictionary_byReference() 来代替引用字典内容
  注意3 : 使用 ZSTD_DCtx_loadDictionary_advanced() 来控制
              如何加载和解释字典内容
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_refDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict);
</b><p>  引用准备好的字典，用于解压下一帧
  在使用相同的DCtx解压未来的帧时，该字典仍然有效
 @result : 0, 或一个错误代码(可以用 ZSTD_isError() 测试)
  注意1：目前，只能管理一个字典
            引用一个新的字典会有效地 "丢弃" 之前的任何一个字典
   特别：引用一个NULL DDict 意味着 "返回到无字典模式"
  注意2：DDict 只是被引用，它的寿命必须超过 DCtx 的使用时间
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_refPrefix(ZSTD_DCtx* dctx,
                     const void* prefix, size_t prefixSize);
</b><p>  引用一个前缀(单用途字典)来解压下一帧
  这是 ZSTD_CCtx_refPrefix() 的反向操作
  并且必须使用与压缩过程中使用的相同的前缀
  前缀 **只使用一次**，引用在帧结束时被丢弃
  当 ZSTD_decompressStream() 返回 0 时达到帧结束
  当 ZSTD_decompressStream() 返回 0 时，帧结束
@result : 0，或者一个错误代码(可以用 ZSTD_isError() 测试)
  注1 : 添加任何前缀(包括NULL) 都会使之前设置的前缀或字典无效
  注2：前缀缓冲区被引用。它**必须**于解压时间
           前缀缓冲区必须保持不变，直到帧结束
           当 ZSTD_decompressStream() 返回 0 时达到
  注3：默认情况下，前缀被视为原始内容 (ZSTD_dct_rawContent)
           使用 ZSTD_CCtx_refPrefix_advanced() 来改变 dictMode (实验部分)
  注4：引用一个原始内容前缀几乎没有任何cpu或内存成本
           一个完整的字典开销是比较大的，因为它需要建立表
</p></pre><BR>

<pre><b>size_t ZSTD_sizeof_CCtx(const ZSTD_CCtx* cctx);
size_t ZSTD_sizeof_DCtx(const ZSTD_DCtx* dctx);
size_t ZSTD_sizeof_CStream(const ZSTD_CStream* zcs);
size_t ZSTD_sizeof_DStream(const ZSTD_DStream* zds);
size_t ZSTD_sizeof_CDict(const ZSTD_CDict* cdict);
size_t ZSTD_sizeof_DDict(const ZSTD_DDict* ddict);
</b><p>  这些函数给出了所选对象 _当前_ 的内存使用情况
  请注意，对象的内存使用量可以随着时间的推移而变化（增加或减少）
</p></pre><BR>

<a name="Chapter14"></a><h2>实验性 API (仅静态链接)</h2><pre>
 下列符号和常数
 不计划在近期加入 "稳定的 API" 状态
 它们仍然可以在未来的版本中改变
 它们中的一些计划无限期地保留在 static_only 部分
 它们中的一些可能会在未来被移除（特别是当与现有的稳定函数多余的时候

<BR></pre>

<pre><b>typedef struct {
    unsigned int offset;      </b>/* 匹配的偏移量 (与偏移量代码不同)
                               * 如果 offset == 0 且 matchLength == 0，则该序列代表
                               * litLength 大小的块中的最后一个 iteral
                               */<b>

    unsigned int litLength;   </b>/* 序列的字面长度 */<b>
    unsigned int matchLength; </b>/* 序列的匹配长度 */<b>
    
                              </b>/* 注意：该 API 的用户可以提供一个 matchLength == litLength == offset == 0 的序列
                               * 在这种情况下，我们将把该序列作为块边界的标记
                               */<b>
    
    unsigned int rep;         </b>/* 表示 "offset" 字段代表哪个重复偏移量
                               * 范围为 [0, 3].
                               *
                               * 重复偏移量实质上是按时间顺序排序的前一个序列的前一个偏移量
                               * 更多细节，请参见doc/zstd_compression_format.md
                               *
                               * 如果 rep == 0, 那么 'offset' 不包含重复偏移
                               * 如果 rep > 0:
                               *  if litLength != 0:
                               *      rep == 1 --> offset == repeat_offset_1
                               *      rep == 2 --> offset == repeat_offset_2
                               *      rep == 3 --> offset == repeat_offset_3
                               *  if litLength == 0:
                               *      rep == 1 --> offset == repeat_offset_2
                               *      rep == 2 --> offset == repeat_offset_3
                               *      rep == 3 --> offset == repeat_offset_1 - 1
                               *
                               * 注意：这个字段是可选的，ZSTD_generateSequences() 将计算 'rep' 的值
                               * 但从外部序列提供者的角度来看，重复偏移量不一定需要计算
                               * 例如，ZSTD_compressSequences() 根本不使用这个 'rep' 字段（目前）
                               */<b>
} ZSTD_Sequence;
</b></pre><BR>
<pre><b>typedef struct {
    unsigned windowLog;       </b>/**< 最大的匹配距离：较大的匹配距离 == 更多的压缩，解压时需要更多的内存 */<b>
    unsigned chainLog;        </b>/**< 完全搜索段：更大 == 更多的压缩，更慢，更多的内存(对快速搜索无用) */<b>
    unsigned hashLog;         </b>/**< 派遣表：更大的 == 更快的，更多的内存 */<b>
    unsigned searchLog;       </b>/**< 搜索的数量 : 更大的 == 更多的压缩，更慢 */<b>
    unsigned minMatch;        </b>/**< 搜索到的匹配长度：较大的匹配长度 == 更快的解压速度，有时较少的压缩 */<b>
    unsigned targetLength;    </b>/**< 最佳解析器的可接受匹配大小(仅适用于)：更大的匹配大小 == 更多的压缩，更慢 */<b>
    ZSTD_strategy strategy;   </b>/**< 见上文 ZSTD_strategy 定义 */<b>
} ZSTD_compressionParameters;
</b></pre><BR>
<pre><b>typedef struct {
    int contentSizeFlag; </b>/**< 1: 内容大小将在帧头中 (when known) */<b>
    int checksumFlag;    </b>/**< 1: 在帧尾使用 XXH64 算法生成一个 32-bits 的校验和，用于错误检测 */<b>
    int noDictIDFlag;    </b>/**< 1: 不将 dictID 保存到帧头（dictID只对字典压缩有用） */<b>
} ZSTD_frameParameters;
</b></pre><BR>
<pre><b>typedef struct {
    ZSTD_compressionParameters cParams;
    ZSTD_frameParameters fParams;
} ZSTD_parameters;
</b></pre><BR>
<pre><b>typedef enum {
    ZSTD_dct_auto = 0,       </b>/* 以 ZSTD_MAGIC_DICTIONARY 开头的字典为 "full"，否则为 "rawContent" */<b>
    ZSTD_dct_rawContent = 1, </b>/* 确保字典总是以 rawContent 加载，即使它以ZSTD_MAGIC_DICTIONARY开头 */<b>
    ZSTD_dct_fullDict = 2    </b>/* 如果不尊重 Zstandard 的规范，拒绝加载字典，从ZSTD_MAGIC_DICTIONARY 开始 */<b>
} ZSTD_dictContentType_e;
</b></pre><BR>
<pre><b>typedef enum {
    ZSTD_dlm_byCopy = 0,  </b>/**< 在内部复制字典内容 */<b>
    ZSTD_dlm_byRef = 1    </b>/**< 引用字典内容 -- 字典缓冲区必须超过其调用者的生命周期 */<b>
} ZSTD_dictLoadMethod_e;
</b></pre><BR>
<pre><b>typedef enum {
    ZSTD_f_zstd1 = 0,           </b>/* zstd 帧格式，在 zstd_compression_format.md中指定（默认） */<b>
    ZSTD_f_zstd1_magicless = 1  </b>/* zstd 帧格式的变体，没有初始的 4-bytes 魔数
                                 * 用于为每个生成的帧节省4个字节
                                 * 解码器不能自动识别这种格式，需要此指令 */<b>
} ZSTD_format_e;
</b></pre><BR>
<pre><b>typedef enum {
    </b>/* 注意：这个枚举控制 ZSTD_d_forceIgnoreChecksum */<b>
    ZSTD_d_validateChecksum = 0,
    ZSTD_d_ignoreChecksum = 1
} ZSTD_forceIgnoreChecksum_e;
</b></pre><BR>
<pre><b>typedef enum {
    </b>/* 注意：这个枚举和它所控制的行为实际上是压缩机的内部实现细节
     * 预计这些细节将继续发展，只应在极其先进的性能调整的情况下考虑
     *
     * Zstd 目前支持以三种方式使用 CDict :
     *
     * - CDict 的内容可以复制到工作环境中
     *   这意味着压缩可以搜索字典和输入，同时在一组内部表上操作
     *   这使得每字节输入的压缩速度更快，然而，CDict 表的初始副本在压缩
     *   开始时产生了固定的成本，对于小的压缩（< 8 KB），该副本可能会主导压缩成本
     *
     * - CDict 的表可以就地使用，在这种模式下，每个输入字节的压缩速度较慢，
     *   因为压缩机必须搜索两套表，然而，这种模式不产生启动成本(只要工作上下文的表格可以重复使用)
     *   对于小的输入，这可以是 比复制CDict的表格更快
     *
     * - CDict 的表根本没有被使用，相反，我们只使用工作上下文来重新加载字典
     *   并使用基于源大小的参数，参见ZSTD_compress_insertDictionary() 和 ZSTD_compress_usingDict()
     *   当字典大小相对于输入大小非常小，而输入大小一开始就相当大时，这个方法是有效的
     *
     * Zstd 有一个简单的内部启发式方法，可以选择在压缩开始时使用哪种策略
     * 但是，如果实验表明 Zstd 的选择不对，可以用这个枚举覆盖这个选择
     */<b>
    ZSTD_dictDefaultAttach = 0, </b>/* 使用默认的启发式 */<b>
    ZSTD_dictForceAttach   = 1, </b>/* 从不复制字典 */<b>
    ZSTD_dictForceCopy     = 2, </b>/* 总是复制字典 */<b>
    ZSTD_dictForceLoad     = 3  </b>/* 总是重载字典 */<b>
} ZSTD_dictAttachPref_e;
</b></pre><BR>
<pre><b>typedef enum {
  ZSTD_lcm_auto = 0,          </b>/**< 根据压缩等级自动确定压缩模式，负的压缩级别将不被压缩，正的压缩级别将被压缩 */<b>
  ZSTD_lcm_huffman = 1,       </b>/**< 总是尝试 Huffman 压缩，如果 Huffman 压缩无利可图，仍会发出未压缩的文字 */<b>
  ZSTD_lcm_uncompressed = 2   </b>/**< 总是发出未压缩的文字 */<b>
} ZSTD_literalCompressionMode_e;
</b></pre><BR>
<a name="Chapter15"></a><h2>帧大小函数</h2><pre></pre>

<pre><b>unsigned long long ZSTD_findDecompressedSize(const void* src, size_t srcSize);
</b><p>  `src` 应指向一系列 ZSTD 编码和/或可跳过的帧的开始
  `srcSize` 必须是这个系列的精确大小
       (即在 `src + srcSize` 处应该有一个帧边界)
  @return : - 所有连续帧中所有数据的解压缩大小
            - 如果不能确定解压后的大小，则使用 ZSTD_CONTENTSIZE_UNKNOWN
            - 如果发生了错误，那么 ZSTD_CONTENTSIZE_ERROR

   注意1 ： 解压大小是一个可选的字段，可能不存在，特别是在数据流模式下
           当 `return== ZSTD_CONTENTSIZE_UNKNOWN` 时，要解压的数据可以是任何大小
           在这种情况下，就需要使用数据流模式来解压数据
   注意2 ： 当使用 ZSTD_compress() 进行压缩时，解压后的大小总是存在的
   注意3 ： 解压后的大小可以很大（64-bits值）
           潜在地大于本地系统所能处理的单个内存段
           在这种情况下，就需要使用数据流模式来解压数据
   注意4 ： 如果源是不受信任的，解压大小可能是错误的或故意修改的
           始终确保结果符合应用程序的授权限制
           每个应用程序可以设置自己的限制
   注意5 ： ZSTD_findDecompressedSize 处理多个帧
           因此它必须遍历输入到 读取每个包含的帧头，这样做的速度很快，因为大部分数据被跳过
           然而，这确实意味着所有的帧数据必须存在且有效
</p></pre><BR>

<pre><b>unsigned long long ZSTD_decompressBound(const void* src, size_t srcSize);
</b><p>  `src` 应指向一系列 ZSTD 编码和/或可跳过的帧的开始
  `srcSize`必须是这个系列的精确大小
       (即`src + srcSize处应该有一个帧边界)
  @return : - 所有连续帧中所有数据的解压缩大小的上限
            - 如果发生了错误：ZSTD_CONTENTSIZE_ERROR

  注意1：如果`src`包含一个无效的或格式不正确的帧，就会发生错误。
  注意2：当`src`的每个ZSTD编码帧中都有解压大小字段时，上界是准确的
            在这种情况下，`ZSTD_findDecompressedSize` 和 `ZSTD_decompressBound` 返回相同的值
  注意3：当解压大小字段不可用时，该帧的上界由以下方法计算
              upper-bound = # blocks * min(128 KB, Window_Size)
</p></pre><BR>

<pre><b>size_t ZSTD_frameHeaderSize(const void* src, size_t srcSize);
</b><p>  srcSize 必须 >=  ZSTD_FRAMEHEADERSIZE_PREFIX
 @return : 帧头的大小
           或一个错误代码（如果srcSize太小）
</p></pre><BR>

<pre><b>typedef enum {
  ZSTD_sf_noBlockDelimiters = 0,         </b>/* ZSTD_Sequence 的表示方式没有块定界符，只有序列 */<b>
  ZSTD_sf_explicitBlockDelimiters = 1    </b>/* ZSTD_Sequence 的表示方式包含明确的区块定界符 */<b>
} ZSTD_sequenceFormat_e;
</b></pre><BR>
<pre><b></b><p> 使用 ZSTD_compress2 生成序列，给定一个源缓冲区

 每个块将以一个虚数序列结束
 offset==0，matchLength==0，litLength==最后一个字符的长度
 litLength 可能是 == 0，如果是这样，那么 (of: 0 ml: 0 ll: 0)
 的序列就会简单地作为一个块的分隔符

 zc 可以用来插入自定义压缩参数
 这个函数调用 ZSTD_compress2

 该函数的输出可以通过 CCtx_compressSequences() 输入到 ZSTD_compressSequences() 中
 将 ZSTD_c_blockDelimiters 设置为 ZSTD_sf_explicitBlockDelimiters
 @return ： 生成的序列数
</p></pre><BR>

<pre><b>size_t ZSTD_mergeBlockDelimiters(ZSTD_Sequence* sequences, size_t seqsSize);
</b><p> 给定一个 ZSTD_Sequence 数组，删除所有代表块定界符/最后一个字符的序列
 合并到下一个序列的字面上

 因此，最终生成的结果没有明确的块边界表示
 而最后一个字段在序列中没有表示

 这个函数的输出可以通过 CCtx_compressSequences() 输入到ZSTD_compressSequences() 中
 将 ZSTD_c_blockDelimiters 设置为 ZSTD_sf_noBlockDelimiters
 @return : 合并后剩余的序列数
</p></pre><BR>

<pre><b>size_t ZSTD_compressSequences(ZSTD_CCtx* const cctx, void* dst, size_t dstSize,
                      const ZSTD_Sequence* inSeqs, size_t inSeqsSize,
                      const void* src, size_t srcSize);
</b><p> 将原始源缓冲区生成的 ZSTD_Sequence 数组压缩成 dst
 如果包含一个字典，那么 cctx 应该引用 dict，(参见：ZSTD_CCtx_refCDict()，ZSTD_CCtx_loadDictionary() 等)
 整个源文件被压缩成一帧

 压缩行为根据 cctx 参数而改变，特别是：
    如果 ZSTD_c_blockDelimiters == ZSTD_sf_noBlockDelimiters，则 ZSTD_Sequence 的数组将包含以下内容
    没有块定界符（在 ZSTD_Sequence 中定义），块的边界是根据从 cctx 导出的块大小，序列可以被分割，这是默认设置

    如果 ZSTD_c_blockDelimiters == ZSTD_sf_explicitBlockDelimiters，则 ZSTD_Sequence 的数组中会含有
    块定界符（在ZSTD_Sequence中定义），如果没有提供块定界符，则行为未定义
    
    如果 ZSTD_c_validateSequences == 0，这个函数将盲目接受提供的序列，无效的序列将导致未定义的行为
    如果 ZSTD_c_validateSequences == 1，那么如果序列无效 (参见 doc/zstd_compression_format.md
    关于偏移量/匹配长度要求的具体细节），然后函数将退出并返回一个错误
    
    除了这两个可调节的实验参数外，还有其他重要的 cctx 参数
    - ZSTD_c_minMatch 必须设置为小于或等于匹配查找器产生的最小匹配，它的最小值为 ZSTD_MINMATCH_MIN
    - ZSTD_c_compressionLevel 相应地调整编码器的强度，就像在典型的压缩中一样
    - ZSTD_c_windowLog 会影响偏移量的验证：如果提供的偏移量在较高的调试级别，这个函数会返回一个错误
      大于规范对给定窗口日志和字典（如果存在）的允许值，参见: doc/zstd_compression_format.md

 注意1 ： 目前为止，Repcodes 总是在这个函数中重新计算，所以 ZSTD_Sequence::rep 没有被使用
 注意2 ： 一旦我们整合了摄取 Repcodes 的能力，那么显式块 delims 模式必须完全尊重这些 Repcodes
         并且不能发出与 repcode 历史记录不一致的 RLE块
 @return ： 最终的压缩大小或 ZSTD 错误
</p></pre><BR>

<a name="Chapter16"></a><h2>内存管理</h2><pre></pre>

<pre><b>size_t ZSTD_estimateCCtxSize(int compressionLevel);
size_t ZSTD_estimateCCtxSize_usingCParams(ZSTD_compressionParameters cParams);
size_t ZSTD_estimateCCtxSize_usingCCtxParams(const ZSTD_CCtx_params* params);
size_t ZSTD_estimateDCtxSize(void);
</b><p>  这些函数可以在创建 {D,C}Ctx 之前，估计未来的内存使用量

  ZSTD_estimateCCtxSize() 将为任何压缩级别提供足够大的内存预算，直至选定的级别
  注意1 ： 与 ZSTD_estimateCStreamSize*() 不同的是，这个估计值
          不包括窗口缓冲区的空间
          因此，估计只对单次压缩有保证，而不是数据流
  该估计将假设输入可能是任意大的，这是最坏的情况

  当 srcSize 可以被一个已知的、相当 "小 "的值所约束时
  这个事实可以用来提供一个更严格的估计
  因为 CCtx 压缩上下文将需要更少的内存
  这种更严格的估计可以由更高级的函数来提供
  ZSTD_estimateCCtxSize_usingCParams()，可以和 ZSTD_getCParams() 一起使用
  ZSTD_estimateCCtxSize_usingCCtxParams()，可与 ZSTD_CCtxParams_setParameter() 配合使用
  两者都可用于使用自定义压缩参数和任意的 srcSize 限制来估计内存

  注意2 ： 只支持单线程压缩
  ZSTD_estimateCCtxSize_usingCCtxParams() 会在 ZSTD_c_nbWorkers>=1 的情况下返回一个错误代码
</p></pre><BR>

<pre><b>size_t ZSTD_estimateCStreamSize(int compressionLevel);
size_t ZSTD_estimateCStreamSize_usingCParams(ZSTD_compressionParameters cParams);
size_t ZSTD_estimateCStreamSize_usingCCtxParams(const ZSTD_CCtx_params* params);
size_t ZSTD_estimateDStreamSize(size_t windowSize);
size_t ZSTD_estimateDStreamSize_fromFrame(const void* src, size_t srcSize);
</b><p>  ZSTD_estimateCStreamSize() 将为任何压缩级别提供足够大的预算，直到选定的级别
  它也会认为 src 大小是任意的 "大"，这是最坏的情况
  如果已知 srcSize 总是小的，ZSTD_estimateCStreamSize_usingCParams() 可以提供一个更严格的估计
  ZSTD_estimateCStreamSize_usingCParams() 可以与  ZSTD_getCParams()一起使用，从 compressionLevel 创建 cParams
  ZSTD_estimateCStreamSize_usingCCtxParams() 可以与ZSTD_CCtxParams_setParameter() 串联使用
  仅支持单线程压缩，如果ZSTD_c_nbWorkers>=1，该函数将返回错误代码

  注意1 ： CStream 大小估计只对单线程压缩正确
          ZSTD_DStream 的内存预算取决于窗口大小
          这个信息可以手动传递，使用 ZSTD_estimateDStreamSize
          或者使用 ZSTD_estimateDStreamSize_fromFrame() 从一个有效的帧头中扣除

  注意2 ： 如果流是用函数 ZSTD_init?Stream_usingDict() 初始化的
          将创建一个内部  "Dict"，这里不估计额外的大小
          在这种情况下，通过添加 ZSTD_estimate?DictSize 来获得总大小
</p></pre><BR>

<pre><b>size_t ZSTD_estimateCDictSize(size_t dictSize, int compressionLevel);
size_t ZSTD_estimateCDictSize_advanced(size_t dictSize, ZSTD_compressionParameters cParams, ZSTD_dictLoadMethod_e dictLoadMethod);
size_t ZSTD_estimateDDictSize(size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod);
</b><p>  ZSTD_estimateCDictSize() 会赌 src 大小比较 "小"，内容被复制，就像 ZSTD_createCDict() 一样
  ZSTD_estimateCDictSize_advanced() 可以像 ZSTD_createCDict_advanced() 一样，精确控制压缩参数
  注意 ： 通过引用创建的字典 (`ZSTD_dlm_byRef`) 在逻辑上更小
</p></pre><BR>

<pre><b>ZSTD_CCtx*    ZSTD_initStaticCCtx(void* workspace, size_t workspaceSize);
ZSTD_CStream* ZSTD_initStaticCStream(void* workspace, size_t workspaceSize);    </b>/**< same as ZSTD_initStaticCCtx() */<b>
</b><p>  使用预先分配的固定大小的缓冲区初始化一个对象
  workspace : 要将对象放入的内存区域
              提供的指针 *必须是8-bytes对齐的*
              缓冲区必须比对象的生命周期长
  workspaceSize : 工作空间大小，使用 ZSTD_estimate*Size() 来确定对象的工作空间大小
                  工作空间必须有多大才能支持目标场景
 @return : 对象指针（与工作空间地址相同，只是类型不同）或NULL，如果出错（大小太小，对齐方式不正确等）

  注意1 ： 当使用静态缓冲区时，zstd 永远不会调整大小或 malloc()
          如果对象需要的内存大于可用的内存，那么 zstd 将不会调整大小或malloc()
          zstd 会直接出错（典型的是 ZSTD_error_memory_allocation）
  注意2 ： 没有相应的 "free" 函数
          因为工作空间是外部分配的，所以也必须从外部释放
  注意3 ： cParams : 使用 ZSTD_getCParams() 来转换压缩级别
          到其关联的 cParams 中
  限制1 ： 目前与内部字典的创建不兼容，触发的是
          ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() 或ZSTD_initDStream_usingDict()
  限制2 ： 静态 cctx 目前与多线程不兼容
  限制3 ： static dctx 与传统支持不兼容
</p></pre><BR>

<pre><b>ZSTD_DStream* ZSTD_initStaticDStream(void* workspace, size_t workspaceSize);    </b>/**< 与 ZSTD_initStaticDCtx() 相同 */<b>
</b></pre><BR>
<pre><b>typedef void* (*ZSTD_allocFunction) (void* opaque, size_t size);
typedef void  (*ZSTD_freeFunction) (void* opaque, void* address);
typedef struct { ZSTD_allocFunction customAlloc; ZSTD_freeFunction customFree; void* opaque; } ZSTD_customMem;
static
#ifdef __GNUC__
__attribute__((__unused__))
#endif
ZSTD_customMem const ZSTD_defaultCMem = { NULL, NULL, NULL };  </b>/**< 这个常量服从于 stdlib 的函数 */<b>
</b><p>  这些原型使得传递自己的分配/释放函数成为可能
  ZSTD_customMem 在创建时提供，使用下面列出的ZSTD_create*_advanced() 变体
  所有的分配/释放操作都将使用这些自定义变体来完成，而不是常规的 &lt;stdlib.h&gt; 变体
</p></pre><BR>

<a name="Chapter17"></a><h2>高级压缩函数</h2><pre></pre>

<pre><b>ZSTD_CDict* ZSTD_createCDict_byReference(const void* dictBuffer, size_t dictSize, int compressionLevel);
</b><p>  创建一个压缩用的消化词典
  字典内容只是被引用，而不是重复
  因此，`dictBuffer` **必须** 超过 CDict 的生命周期
  且其内容必须在 CDict 的整个生命周期内保持不变
  注意 ： 等同于 ZSTD_createCDict_advanced()，dictLoadMethod==ZSTD_dlm_byRef
</p></pre><BR>

<pre><b>unsigned ZSTD_getDictID_fromCDict(const ZSTD_CDict* cdict);
</b><p>  提供加载到 `cdict` 中的字典的 dictID
  如果 @return == 0，表示该字典不符合 Zstandard 规范，或为空
  不符合标准的字典仍然可以被加载，但只作为内容字典
</p></pre><BR>

<pre><b>ZSTD_compressionParameters ZSTD_getCParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);
</b><p> @return ZSTD_compressionParameters 结构，用于选择压缩级别和估计的 srcSize
 `estimatedSrcSize` 值是可选的，如果不知道，选择0

<pre><b>ZSTD_parameters ZSTD_getParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);
</b><p>  与 ZSTD_getCParams() 相同，但 @return 一个完整的 `ZSTD_parameters` 对象，而不是子组件 `ZSTD_compressionParameters`
  `ZSTD_frameParameters` 的所有字段都设置为默认值：contentSize=1, checksum=0, noDictID=0
</p></pre><BR>

<pre><b>size_t ZSTD_checkCParams(ZSTD_compressionParameters params);
</b><p>  确保参数值保持在授权范围内
 @return 0 成功，或者返回错误代码（可以用 ZSTD_isError() 检查）
</p></pre><BR>

<pre><b>ZSTD_compressionParameters ZSTD_adjustCParams(ZSTD_compressionParameters cPar, unsigned long long srcSize, size_t dictSize);
</b><p>  优化给定 `srcSize` 和 `dictSize` 的参数
  `srcSize` 可以是未知的，在这种情况下使用ZSTD_CONTENTSIZE_UNKNOWN
  当没有字典时，`dictSize` 必须是 `0`
  cPar 可以是无效的 ： 所有的参数都将被限制在 @return 结构的有效范围内
  这个函数永远不会失败(宽合同)
</p></pre><BR>

<pre><b>size_t ZSTD_compress_advanced(ZSTD_CCtx* cctx,
                              void* dst, size_t dstCapacity,
                        const void* src, size_t srcSize,
                        const void* dict,size_t dictSize,
                              ZSTD_parameters params);
</b><p>  注意：这个函数现在已经被取消了，可以用ZSTD_compress2() 代替
         它可以被 ZSTD_compress2() 和 ZSTD_CCtx_setParameter() 以及其他参数设置器取代
  这个原型将被标记为废弃，并在达到 v1.5.x 时产生编译警告
</p></pre><BR>

<pre><b>size_t ZSTD_compress_usingCDict_advanced(ZSTD_CCtx* cctx,
                                  void* dst, size_t dstCapacity,
                            const void* src, size_t srcSize,
                            const ZSTD_CDict* cdict,
                                  ZSTD_frameParameters fParams);
</b><p>  注意 ： 这个函数现在是多余的
         它可以被 ZSTD_compress2()，结合ZSTD_CCtx_loadDictionary() 和其他参数设置器取代
  这个原型将被标记为废弃，并在未来的版本中产生编译警告
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_loadDictionary_byReference(ZSTD_CCtx* cctx, const void* dict, size_t dictSize);
</b><p>  与 ZSTD_CCtx_loadDictionary() 相同，但字典内容被引用，而不是被复制到CCtx中
  它节省了一些内存，但也要求 `dict` 在 `cctx` 中的使用时间超过其使用时间
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_loadDictionary_advanced(ZSTD_CCtx* cctx, const void* dict, size_t dictSize,
                    ZSTD_dictLoadMethod_e dictLoadMethod, ZSTD_dictContentType_e dictContentType);
</b><p>  和 ZSTD_CCtx_loadDictionary() 一样，但比 ZSTD_CCtx_loadDictionary() 的控制更精细
  如何加载字典（通过复制？ 通过引用？）
  以及如何解释它（自动模式？ 强制生模式？ 完全模式？）
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_refPrefix_advanced(ZSTD_CCtx* cctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType);
</b><p>  和 ZSTD_CCtx_refPrefix() 一样，但给了更精细的控制
  如何解释前缀内容（自动？ 强制生模式（默认）？ 全模式？）
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_getParameter(ZSTD_CCtx* cctx, ZSTD_cParameter param, int* value);
</b><p>  获取请求的压缩参数值，由 ZSTD_cParameter 枚举选择
  并将其存储为 int* 值。
 @return : 0，或者一个错误代码（可以用 ZSTD_isError() 测试）
</p></pre><BR>

<pre><b>ZSTD_CCtx_params* ZSTD_createCCtxParams(void);
size_t ZSTD_freeCCtxParams(ZSTD_CCtx_params* params);
</b><p>  Quick howto :
  - ZSTD_createCCtxParams() : 创建一个 ZSTD_CCtx_params 结构
  - ZSTD_CCtxParams_setParameter() : 将参数逐一推送到各个参数库中
                                     现有的 ZSTD_CCtx_params 结构
                                     这类似于 ZSTD_CCtx_setParameter()
  - ZSTD_CCtx_setParametersUsingCCtxParams() : 将参数应用于 CCtxParams
                                    现有的 CCtx
                                    这些参数将应用于
                                    的所有后续帧
  - ZSTD_compressStream2() : 使用 CCtx 进行压缩
  - ZSTD_freeCCtxParams() : 释放内存

  这可以和 ZSTD_estimateCCtxSize_advanced_usingCCtxParams()  一起使用
  用于单线程压缩的CCtx的静态分配
</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_reset(ZSTD_CCtx_params* params);
</b><p>  重置参数为默认值
</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_init(ZSTD_CCtx_params* cctxParams, int compressionLevel);
</b><p>  根据压缩级别初始化 cctxParams 的压缩参数
  所有其他参数均重置为默认值
</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_init_advanced(ZSTD_CCtx_params* cctxParams, ZSTD_parameters params);
</b><p>  根据 params 初始化 cctxParams 的压缩和帧参数
  所有其他参数都会被重置为默认值
</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_setParameter(ZSTD_CCtx_params* params, ZSTD_cParameter param, int value);
</b><p>  类似于 ZSTD_CCtx_setParameter
  设置一个压缩参数，由 enum ZSTD_cParameter 选择
  参数必须应用于 ZSTD_CCtx，使用
  ZSTD_CCtx_setParametersUsingCCtxParams()
@result : 一个代表成功或失败的代码(可以用 ZSTD_isError() 测试)
</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_getParameter(ZSTD_CCtx_params* params, ZSTD_cParameter param, int* value);
</b><p> 类似于 ZSTD_CCtx_getParameter
 获取一个压缩参数的请求值，由 ZSTD_cParameter 枚举选择
 @result : 0，或者一个错误代码(可以用 ZSTD_isError() 测试)
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_setParametersUsingCCtxParams(
        ZSTD_CCtx* cctx, const ZSTD_CCtx_params* params);
</b><p>  将一组 ZSTD_CCtx_params 应用到压缩上下文
  这可以在压缩开始后进行
    如果 nbWorkers==0，在开始新的压缩之前不会有任何影响
    如果 nbWorkers>=1，新的参数将在下一个作业中被接收
       但有一些限制（windowLog、pledgedSrcSize、nbWorkers、jobSize 和 overlapLog不更新）
</p></pre><BR>

<pre><b>size_t ZSTD_compressStream2_simpleArgs (
                ZSTD_CCtx* cctx,
                void* dst, size_t dstCapacity, size_t* dstPos,
          const void* src, size_t srcSize, size_t* srcPos,
                ZSTD_EndDirective endOp);
</b><p>  与 ZSTD_compressStream2() 相同
  但只使用积分类型作为参数
  这个变体可能对来自动态语言的绑定有帮助
  这些结构在处理包含内存指针的结构时有问题
</p></pre><BR>

<a name="Chapter18"></a><h2>高级解压函数</h2><pre></pre>

<pre><b>unsigned ZSTD_isFrame(const void* buffer, size_t size);
</b><p>  说明 "buffer" 的内容是否以有效的 Frame Identifier 开始
  注意1：Frame Identifier 是4 bytes，如果 "size < 4"，@return 将始终为 0
  注意2：Legacy Frame Identifier 只有在 Legacy Support 启用时才被认为是有效的
  注意3：可跳过的帧标识符被认为是有效的
</p></pre><BR>

<pre><b>ZSTD_DDict* ZSTD_createDDict_byReference(const void* dictBuffer, size_t dictSize);
</b><p>  创建一个消化后的字典，准备好开始解压操作，没有启动延迟
  字典内容会被引用，因此会留在dictBuffer中
  重要的是，dictBuffer 的生命周期要超过 DDict
  它必须在 DDict 的整个生命周期内保持可读性
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_loadDictionary_byReference(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);
</b><p>  与 ZSTD_DCtx_loadDictionary() 相同。
  但引用 `dict` 内容，而不是将其复制到 `dctx` 中
  如果 `dict` 还在的话，这样可以节省内存
  然而，在使用 `dict` 时，`dict` 必须保持可访问性（且不被修改），所以它必须在解压后仍能使用
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx, const void* dict, size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod, ZSTD_dictContentType_e dictContentType);
</b><p>  与 ZSTD_DCtx_loadDictionary() 相同
  但却能直接控制
  如何加载字典(通过复制？ 通过参考？)
  以及如何解释它(自动？ 强制生模式？ 仅全模式？)
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_refPrefix_advanced(ZSTD_DCtx* dctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType);
</b><p>  和 ZSTD_DCtx_refPrefix() 一样，但给了更精细的控制
  如何解释前缀内容（自动？ 强制生模式（默认）？ 全模式？）
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_setMaxWindowSize(ZSTD_DCtx* dctx, size_t maxWindowSize);
</b><p>  拒绝为要求窗口大小大于规定限制的帧分配内部缓冲区
  这可以保护解码器上下文，避免为自己保留过多的内存（潜在的攻击情况）
  这个参数只在数据流模式下有用，因为在单通道模式下不分配内部缓冲区
  默认情况下，解压上下文接受所有窗口大小 <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT)
 @return : 0，或者一个错误代码（可以用 ZSTD_isError() 来测试）

</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_getParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int* value);
</b><p>  获取要求的解压参数值，由 enum ZSTD_dParameter 选择
  并将其存储为 int* 值。
 @return : 0，或者一个错误代码（可以用 ZSTD_isError() 测试）

</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_setFormat(ZSTD_DCtx* dctx, ZSTD_format_e format);
</b><p>  向解码器上下文指示下一步要解码的数据种类
  这条指令对没有完整格式头的数据解码是必须的
  例如 ZSTD_f_zstd1_magicless
 @return : 0，或者一个错误代码(可以用 ZSTD_isError() 来测试)
</p></pre><BR>

<pre><b>size_t ZSTD_decompressStream_simpleArgs (
                ZSTD_DCtx* dctx,
                void* dst, size_t dstCapacity, size_t* dstPos,
          const void* src, size_t srcSize, size_t* srcPos);
</b><p>  与 ZSTD_decompressStream() 相同
  但只使用积分类型作为参数
  这对于来自动态语言的绑定是很有帮助的
  这些结构在处理包含内存指针的结构时有问题
</p></pre><BR>

<a name="Chapter19"></a><h2>高级数据流函数</h2><pre>  警告：这些功能在Advanced API 中大部分都是多余的
  一旦高级 API 达到 "稳定" 状态
  冗余的功能将被废弃，然后在某些时候被删除
<BR></pre>

<h3>高级数据流压缩函数</h3><pre></pre><b><pre></pre></b><BR>
<pre><b>size_t
ZSTD_initCStream_srcSize(ZSTD_CStream* zcs,
             int compressionLevel,
             unsigned long long pledgedSrcSize);
</b><p>  此功能已被废弃，等同于：
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_refCDict(zcs, NULL); // 清空字典(如果有的话)
     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);

 pledgedSrcSize 必须是正确的，如果在初始化时不知道，使用
 ZSTD_CONTENTSIZE_UNKNOWN. 注意，为了与旧程序兼容
 "0 " 也禁用帧内容大小字段，将来可能会启用
 注意：这个原型将被标记为废弃，并在达到 v1.5.x 时产生编译警告
</p></pre><BR>

<pre><b>size_t
ZSTD_initCStream_usingDict(ZSTD_CStream* zcs,
         const void* dict, size_t dictSize,
               int compressionLevel);
</b><p> 此函数已被废弃，等同于：
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);

 创建一个内部 CDict（与静态 CCtx 不兼容），除非是在
 dict == NULL 或 dictSize < 8，这种情况下，不使用 dict
 注意 : dict 用 ZSTD_dct_auto 加载（如果
 以 ZSTD_MAGIC_DICTIONARY 开头，否则为原始内容）和 ZSTD_dlm_byCopy
 注意：这个原型将被标记为废弃，并在达到v1.5.x时产生编译警告
</p></pre><BR>

<pre><b>size_t
ZSTD_initCStream_advanced(ZSTD_CStream* zcs,
        const void* dict, size_t dictSize,
              ZSTD_parameters params,
              unsigned long long pledgedSrcSize);
</b><p>这个函数已被废弃，大约相当于：
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     // 伪代码：设置每个 zstd 参数，其余的保持原样
     for ((param, value) : params) {
         ZSTD_CCtx_setParameter(zcs, param, value);
     }
     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);

 dict 是用 ZSTD_dct_auto 和 ZSTD_dlm_byCopy 加载的
 pledgedSrcSize 必须正确。
 如果在初始化时不知道 srcSize，则使用 ZSTD_CONTENTSIZE_UNKNOWN
 注意：这个原型将被标记为废弃，并在达到 v1.5.x 时产生编译警告
</p></pre><BR>

<pre><b>size_t ZSTD_initCStream_usingCDict(ZSTD_CStream* zcs, const ZSTD_CDict* cdict);
</b><p> 此函数已被废弃，等同于：
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_refCDict(zcs, cdict);

 注意：cdict 将只是被引用，并且必须在压缩会话结束后继续使用
 注意：这个原型将被标记为废弃，并在达到 v1.5.x 时产生编译警告
</p></pre><BR>

<pre><b>size_t
ZSTD_initCStream_usingCDict_advanced(ZSTD_CStream* zcs,
                   const ZSTD_CDict* cdict,
                         ZSTD_frameParameters fParams,
                         unsigned long long pledgedSrcSize);
</b><p>   该函数已被取消，大约相当于：:
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     // 伪代码：设置每个 zstd 帧参数，其余的保持原样
     for ((fParam, value) : fParams) {
         ZSTD_CCtx_setParameter(zcs, fParam, value);
     }
     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
     ZSTD_CCtx_refCDict(zcs, cdict);

 与 ZSTD_initCStream_usingCDict() 相同，控制帧参数
 pledgedSrcSize 必须正确。如果在初始化时不知道 srcSize，使用
 值ZSTD_CONTENTSIZE_UNKNOWN
 注意：这个原型将被标记为废弃，并在达到 v1.5.x 时产生编译警告
</p></pre><BR>

<pre><b>size_t ZSTD_resetCStream(ZSTD_CStream* zcs, unsigned long long pledgedSrcSize);
</b><p> 该函数已被废弃，等同于：
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);

  开始一个新的帧，使用前一个框架的相同参数
  这通常对跳过字典加载阶段很有用，因为它会在原地重新使用它
  注意在使用 ZSTD_resetCStream() 之前，zcs 必须至少被初始化一次
  如果在重置时不知道 pledgedSrcSize，则使用宏 ZSTD_CONTENTSIZE_UNKNOWN
  如果 pledgedSrcSize > 0，它的值必须是正确的，因为它将被写入头，并在最后控制
  为了与旧程序兼容，暂时将 pledgedSrcSize==0 解释为 "srcSize unknown"
  但在以后的版本中会变成 "empty" 的意思，所以用宏ZSTD_CONTENTSIZE_UNKNOWN代替
 @return : 0, 或一个错误代码(可以用 ZSTD_isError() 来测试)
  注意：这个原型将被标记为废弃，并在达到 v1.5.x 时产生编译警告
</p></pre><BR>

<pre><b>typedef struct {
    unsigned long long ingested;   </b>/* 读取和缓存的输入字节数 */<b>
    unsigned long long consumed;   </b>/* 实际被压缩的输入字节数 */<b>
    unsigned long long produced;   </b>/* 生成和缓存的压缩字节数 */<b>
    unsigned long long flushed;    </b>/* 刷新的压缩字节数：未提供；可从调用者方跟踪 */<b>
    unsigned currentJobID;         </b>/* 仅MT：最近开始的工作编号 */<b>
    unsigned nbActiveWorkers;      </b>/* 仅MT：在探测时主动压缩的工作者数量 */<b>
} ZSTD_frameProgression;
</b></pre><BR>
<pre><b>size_t ZSTD_toFlushNow(ZSTD_CCtx* cctx);
</b><p>  告诉你有多少字节可以立即被刷新
  对多线程场景有用（nbWorkers >= 1）
  探测最老的活动作业，定义为尚未完全刷新的最老作业
  并检查其输出缓冲区
 @return : 最早的作业中存储的数据量，并准备立即刷新
  如果 @return == 0，则意味着：
  + 没有活动的作业(可以用 ZSTD_frameProgression() 来检查)，或
  + 最老的工作仍在积极压缩数据
    但至今为止，它所生产的一切产品也都已被刷新干净
    因此，刷新速度受制于最老作业的生产速度
    无论并发（和新）作业的速度如何
</p></pre><BR>

<h3>高级数据流解压函数</h3><pre></pre><b><pre></pre></b><BR>
<pre><b>size_t ZSTD_initDStream_usingDict(ZSTD_DStream* zds, const void* dict, size_t dictSize);
</b><p>
     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
     ZSTD_DCtx_loadDictionary(zds, dict, dictSize);

 注意：如果 dict == NULL 或 dictSize < 8，将不使用字典
 注意：这个原型将被标记为废弃，并在达到 v1.5.x 时产生编译警告
</p></pre><BR>

<pre><b>size_t ZSTD_initDStream_usingDDict(ZSTD_DStream* zds, const ZSTD_DDict* ddict);
</b><p>
     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
     ZSTD_DCtx_refDDict(zds, ddict);

 注意：引用 ddict 时，它必须在解压会话之后才能使用
 注意：这个原型将被标记为废弃，并在达到 v1.5.x 时产生编译警告
</p></pre><BR>

<pre><b>size_t ZSTD_resetDStream(ZSTD_DStream* zds);
</b><p>
     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);

 重新使用之前 init 中的解压参数，节省字典加载
 注意：这个原型将被标记为废弃，并在达到 v1.5.x 时产生编译警告
</p></pre><BR>

<a name="Chapter20"></a><h2>无缓冲区和同步的内部数据流函数</h2><pre>
  这是一个高级的 API，对于需要直接控制内存的用户来说，它可以完全控制缓冲区的管理
  但它也是一个复杂的，有几个限制，下面有记录
  推荐选择普通的数据流 API，以获得更简单的体验

<BR></pre>

<a name="Chapter21"></a><h2>无缓冲区数据流压缩 (同步模式)</h2><pre>
  需要一个 ZSTD_CCtx 对象来跟踪数据流操作
  使用 ZSTD_createCCtx() / ZSTD_freeCCtx() 来管理资源
  ZSTD_CCtx 对象可以在连续的压缩操作中被多次重复使用

  首先初始化一个上下文
  使用 ZSTD_compressBegin() 或ZSTD_compressBegin_usingDict() 进行字典压缩
  或 ZSTD_compressBegin_advanced()，以实现更精细的参数控制
  也可以使用 ZSTD_copyCCtx() 来复制一个已经被初始化的引用上下文

  然后，使用 ZSTD_compressContinue() 来消耗你的输入
  当使用这个高级函数时，有一些重要的注意事项需要记住
  - ZSTD_compressContinue() 没有内部缓冲区，它只使用外部提供的缓冲区。它只使用外部提供的缓冲区
  - 接口是同步的：输入完全被消耗，并产生 1+ 压缩块
  - 调用者必须确保在最坏情况下，`dst` 中有足够的空间来存储压缩数据
    最坏情况的评估由 ZSTD_compressBound() 提供
    ZSTD_compressContinue() 不保证压缩失败后的恢复
  - ZSTD_compressContinue() 假定之前的输入***仍然可以访问并且未被修改***（最大距离大小，见WindowLog）
    它记住所有之前的连续块，加上一个分离的内存段（它本身可以由多个连续块组成）
  - ZSTD_compressContinue() 检测当 `src` 缓冲区重叠时，先前的输入是否被覆盖
    在这种情况下，它将从历史中 "丢弃 "相关的内存部分

  使用 ZSTD_compressEnd() 完成一帧，它将写入最后一个块和可选的校验和
  可以使用 srcSize==0，在这种情况下，它将写入最后一个空块来结束帧
  如果没有最后一个区块标记，兼容的解码器会认为帧是未完成的（因此是损坏的）

  `ZSTD_CCtx` 对象可以重新使用 (ZSTD_compressBegin()) 来再次压缩
<BR></pre>

<h3>无缓冲区数据流压缩函数</h3><pre></pre><b><pre>size_t ZSTD_compressBegin(ZSTD_CCtx* cctx, int compressionLevel);
size_t ZSTD_compressBegin_usingDict(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, int compressionLevel);
size_t ZSTD_compressBegin_advanced(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, ZSTD_parameters params, unsigned long long pledgedSrcSize);
</b>/**< pledgedSrcSize : 如果初始化时 srcSize 不知道，使用ZSTD_CONTENTSIZE_UNKNOWN */<b>
size_t ZSTD_compressBegin_usingCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict); </b>/**< 注意：如果 cdict==NULL 则失败 */<b>
size_t ZSTD_compressBegin_usingCDict_advanced(ZSTD_CCtx* const cctx,
                                        const ZSTD_CDict* const cdict,
                                     ZSTD_frameParameters const fParams,
                                       unsigned long long const pledgedSrcSize);
</b>/* 压缩参数已经在 cdict 中设置好了， pledgedSrcSize 必须是正确的。如果 srcSize 不知道，使用宏 ZSTD_CONTENTSIZE_UNKNOWN */<b>
size_t ZSTD_copyCCtx(ZSTD_CCtx* cctx, const ZSTD_CCtx* preparedCCtx, unsigned long long pledgedSrcSize);
</b>/**<  注意：如果 pledgedSrcSize 不知道，使用 ZSTD_CONTENTSIZE_UNKNOWN */<b>
</pre></b><BR>
<a name="Chapter22"></a><h2>无缓冲区数据流解压 (同步模式)</h2><pre>
  需要一个ZSTD_DCtx 对象来跟踪数据流操作
  使用 ZSTD_createDCtx() / ZSTD_freeDCtx() 来管理它
  一个 ZSTD_DCtx 对象可以被多次重复使用

  第一个典型的操作是使用 ZSTD_getFrameHeader() 来获取帧参数
  帧头是从压缩帧的开头提取的，所以只提供帧的开头就足够了
  数据片段必须足够大才能保证解码成功
 `ZSTD_frameHeaderSize_max` 字节保证总是足够大
  @result : 0 : 解码成功，`ZSTD_frameHeader` 结构被正确填充
           >0 : `srcSize`太小，请在下一次尝试时提供至少@result字节
           errorCode，可以用ZSTD_isError() 测试

  它在 ZSTD_frameHeader 结构中填充了正确解码帧的重要信息
  如字典ID、内容大小或最大的反向参考距离（`windowSize`）
  请注意，这些值可能是错误的，要么是因为数据损坏，要么是因为第三方故意伪造虚假信息
  因此，请检查这些值是否保持在有效的应用范围内
  例如，不要盲目分配内存，检查 `windowSize` 是否在预期范围内
  每个应用程序可以根据本地的限制，设置自己的限制。
  为了扩展互操作性，建议支持 `windowSize` 至少8MB

  ZSTD_decompressContinue() 在解压过程中需要之前的数据块，最大为`windowSize`字节
  ZSTD_decompressContinue() 对连续性非常敏感
  如果2个区块不相随，请确保要么压缩机在同一地方打破毗连
  或之前的连续段足够大，可以正确处理最大的后参考距离
  有多种方法可以保证这个条件

  最节省内存的方法是使用一个足够大小的圆形缓冲区
  足够的大小是通过调用 ZSTD_decodingBufferSize_min() 来确定的
  如果要求的值对当前系统来说太大了，它可以 @return 一个错误代码（在32-bits 模式下）
  在圆形缓冲区的方法中，ZSTD_decompressContinue()解压前一个块的每一个块
  直到缓冲区中没有足够的空间来保证解码另一个完整的块
  其中最大尺寸在 `ZSTD_frameHeader` 结构中提供，字段 `blockSizeMax`
  这时，解码可以从缓冲区的开始继
  需要注意的是，缓冲区中存储的已经解码的数据在被覆盖之前应该被刷新

  还有一些可能的替代方法，例如使用两个或多个缓冲区，每个缓冲区的大小为 `windowSize`，虽然它们消耗更多的内存

  最后，如果你控制压缩过程，你也可以忽略所有缓冲区大小的规则
  只要编码器和解码器以 "锁步" 方式进行
  也就是使用完全相同的缓冲区大小，在相同的地方打破连续，等等

  一旦缓冲区设置好了，就开始解压，使用ZSTD_decompressBegin()
  如果解压需要使用字典，则使用 ZSTD_decompressBegin_usingDict() 或 ZSTD_decompressBegin_usingDDict()

  然后交替使用 ZSTD_nextSrcSizeToDecompress() 和 ZSTD_decompressContinue()
  ZSTD_nextSrcSizeToDecompress() 告诉了ZSTD_decompressContinue()要提供多少字节作为 'srcSize'
  ZSTD_decompressContinue() 需要这个_精确的字节数，否则会失败

  ZSTD_decompressContinue() 的 @result 是 'dst' 中再生的字节数(一定要<= dstCapacity)
  它可以是零：它只是意味着 ZSTD_decompressContinue() 已经解码了一些元数据项
  它也可以是一个错误代码，可以用 ZSTD_isError() 来测试

  当 ZSTD_nextSrcSizeToDecompress() 返回 0 时，一帧已经完全解密
  然后可以重置上下文来开始新的解压

  注意：使用 ZSTD_nextInputType() 可以知道下一个输入是头还是块
  这个信息不是正确解码一帧所需要的

  == 特殊情况：可跳过的帧

  可跳过的帧允许将用户定义的数据整合到一个连接的帧流中
  可跳过的帧将被解压缩器忽略（跳过）
  可跳过帧的格式如下：
  a) 可跳过的帧ID - 4 Bytes，小端格式，从 0x184D2A50 到 0x184D2A5F 之间的任意值
  b) 帧大小 - 4 Bytes，小端格式，无符号32字节
  c) 帧内容 - 长度等于帧大小的任何内容（用户数据）
  对于可跳过的帧，ZSTD_getFrameHeader() 返回 zfhPtr->frameType==ZSTD_skippableFrame
  对于可跳过的帧，ZSTD_decompressContinue() 总是返回 0：它只跳过内容
<BR></pre>

<h3>无缓冲区数据流解压函数</h3><pre></pre><b><pre>typedef enum { ZSTD_frame, ZSTD_skippableFrame } ZSTD_frameType_e;
typedef struct {
    unsigned long long frameContentSize; </b>/* 如果 == ZSTD_CONTENTSIZE_UNKNOWN, 表示该字段不可用，0表示 "empty" */<b>
    unsigned long long windowSize;       </b>/* 可以非常大，达到 <= frameContentSize */<b>
    unsigned blockSizeMax;
    ZSTD_frameType_e frameType;          </b>/* 如果 == ZSTD_skippableFrame, frameContentSize 是可跳转内容的大小 */<b>
    unsigned headerSize;
    unsigned dictID;
    unsigned checksumFlag;
} ZSTD_frameHeader;
</pre></b><BR>
<pre><b>size_t ZSTD_getFrameHeader(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize);   </b>/**< 不消耗输入 */<b>
</b>/*! ZSTD_getFrameHeader_advanced() :
 *  与 ZSTD_getFrameHeader() 相同
 *  增加了选择格式的能力(如 ZSTD_f_zstd1_magicless) */<b>
size_t ZSTD_getFrameHeader_advanced(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize, ZSTD_format_e format);
size_t ZSTD_decodingBufferSize_min(unsigned long long windowSize, unsigned long long frameContentSize);  </b>/**< 当帧内容大小未知时，传入 frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN */<b>
</b><p>  解码帧头，或需要更大的 `srcSize`
 @return : 0, `zfhPtr` 被正确填充
          >0, `srcSize` 太小，值是需要 `srcSize` 的大小
           或错误代码，可以使用 ZSTD_isError() 来测试
</p></pre><BR>

<pre><b>typedef enum { ZSTDnit_frameHeader, ZSTDnit_blockHeader, ZSTDnit_block, ZSTDnit_lastBlock, ZSTDnit_checksum, ZSTDnit_skippableFrame } ZSTD_nextInputType_e;
</b></pre><BR>
<a name="Chapter23"></a><h2>区块级 API</h2><pre></pre>

<pre><b></b><p>    帧元数据的成本通常是~12字节，对于很小的块（< 100字节）来说，这个成本可能是不可忽略的
    但用户将不得不负责需要的元数据来再生数据，如压缩和内容大小

    几个规则要尊重 。
    - 压缩和解压需要一个上下文结构
      + 使用 ZSTD_createCCtx() 和 ZSTD_createDCtx()
    - 在开始之前，必须先启动上下文
      +压缩：任何 ZSTD_compressBegin*() 变体，包括带字典的
      + 解压：任何 ZSTD_decompressBegin*() 变体，包括带字典的变体
      + copyCCtx() 和copyDCtx() 也可以使用
    - 块的大小是有限制的，必须是 <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX == 128 KB
      + 如果输入的数据大于一个块的大小，则需要将输入数据分割成多个块
      + 对于大于单个块的输入，可以考虑使用常规的 ZSTD_compress() 代替
        帧元数据的成本并不高，而且当源大小大于一个块时，元数据很快就会变得微不足道
    - 当一个块被认为不够可压缩时，ZSTD_compressBlock() 的结果将是0 (0) !
      ===> 在这种情况下，没有任何东西产生到 `dst` 中 !
      + 用户必须测试这样的结果，并直接处理未压缩的数据
      + 如果 ZSTD_compressBlock() 的返回值是 != 0，则不能宣布一个块是不可压缩的
        这样做会扰乱统计历史，导致潜在的数据损坏
      + ZSTD_decompressBlock() _不接受未压缩的数据作为输入_ !!
      + 在有多个连续块的情况下，是否应该对其中的一些块进行解压
        解码器必须被告知它们的存在，以便遵循正确的历史
        使用 ZSTD_insertBlock() 来处理这种情况
</p></pre><BR>

<h3>原始的 zstd 块函数</h3><pre></pre><b><pre>size_t ZSTD_getBlockSize   (const ZSTD_CCtx* cctx);
size_t ZSTD_compressBlock  (ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
size_t ZSTD_decompressBlock(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
size_t ZSTD_insertBlock    (ZSTD_DCtx* dctx, const void* blockStart, size_t blockSize);  </b>/**< 将未压缩的块插入到 `dctx` 历史中，对多块解压有用 */<b>
</pre></b><BR>
</html>
</body>